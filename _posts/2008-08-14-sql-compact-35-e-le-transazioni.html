---
layout: post
title: Sql Compact 3.5 e le transazioni
date: '2008-08-14T05:02:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
modified_time: '2012-08-04T17:54:27.473+02:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-5903894438327262139
blogger_orig_url: http://milestone.topics.it/2008/08/sql-compact-35-e-le-transazioni.html
---

    <span>al fine di fare un po’ di esperimenti sto usando il “nuovo” (si fa per dire) SqlCe 3.5 SP1 (o come diavolo si chiama… ;-)) ma sono incappato in un fastidioso comportamento che non è semplice da aggirare.</span><br>  <span>Se cercate di racchiudere una serie di “SqlCeCommand” in un blocco “TransactionScope” vi beccate una sonora Exception che vi informa che “The Connection object cannot be enlisted in the Transaction”… il motivo è molto semplice SqlCe non supporta le transazioni distribuite (nella versione precedente 3.1 non c’era neppure nessun supporto per System.Transactions, quindi non lamentiamoci troppo) quindi se avete più connessioni aperte verso lo stesso db, nonostante la connection string sia dientica, vengono <em>interpretate</em> come distribuite. Quindi questo si schianta:</span><br>  <span>using( TransactionScope tx = new TransactionScope() )   <br>{    <br>    using( SqlCeConnection cn = new SqlCeConnection( cnStr ) )    <br>    {    <br>        using( SqlCeCommand firstInsert = new SqlCeCommand( cmd, cn ) )    <br>        {    <br>            cn.Open();    <br>            Int32 result = firstInsert.ExecuteNonQuery();    <br>            cn.Close();    <br>        }    <br>    } </span><br>  <span>    using( SqlCeConnection cn = new SqlCeConnection( cnStr ) )   <br>    {    <br>        using( SqlCeCommand secondInsert = new SqlCeCommand( cmd, cn ) )    <br>        {    <br>            cn.Open();    <br>            Int32 result = secondInsert.ExecuteNonQuery();    <br>            cn.Close();    <br>        }    <br>    } </span><br>  <span>    tx.Complete();   <br>}</span><br>  <span>la soluzione è semplice e consta nel condividere la stessa SqlCeConnection, che, bada ben, deve essere aperta prima del primo command e chiusa solo dopo l’ultimo non essendoci connection pooling: </span><br>                                                        <span>using( TransactionScope tx = new TransactionScope() )   <br>{    <br>    using( SqlCeConnection cn = new SqlCeConnection( cnStr ) )    <br>    {    <br>    <br>        <u>cn.Open();</u>    <br>    <br>        using( SqlCeCommand firstInsert = new SqlCeCommand( cmd, cn ) )    <br>        {    <br>            Int32 result = firstInsert.ExecuteNonQuery();    <br>        }    <br>    <br>        using( SqlCeCommand secondInsert = new SqlCeCommand( cmd, cn ) )    <br>        {    <br>            Int32 result = secondInsert.ExecuteNonQuery();    <br>        }    <br>    <br>        <u>cn.Close();</u>    <br>    <br>    } </span><br>  <span>    tx.Complete();   <br>}</span><br>      <span>Siamo sempre alle solite, se avete un’architettura “figosa” fatta a componenti/servizi realizzare questa cosa nel dal non è cero banale, ma “se po fa” :-D</span><br>            <span>.m</span><br>        
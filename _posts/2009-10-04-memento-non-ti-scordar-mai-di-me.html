---
layout: post
title: 'Memento: Non ti scordar mai di me…'
date: '2009-10-04T11:36:00.000+02:00'
author: Mauro Servienti
tags:
- Memento
modified_time: '2012-02-03T13:01:21.352+01:00'
thumbnail: https://lh3.googleusercontent.com/-_46IJNHXdRU/TyvMjBhPEOI/AAAAAAAAAv4/EawNb7VeXM0/s72-c/image_thumb_2.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-4564485249905947350
blogger_orig_url: http://milestone.topics.it/2009/10/memento-non-ti-scordar-mai-di-me.html
permalink: /2009/10/memento-non-ti-scordar-mai-di-me.html
---

<span>Pian piano il tutto sta prendendo forma, i nodi vengono al pettine e le soluzioni (almeno per ora, è il bello del nostro lavoro, panta rei) sembrano finalmente essere soluzioni e non semplici pezze, non puzzano insomma :-)</span><br>  <span>Tutto parte da <a href="http://blogs.ugidotnet.org/topics/archive/2009/07/26/mimando-le-dependency-propertyhellip.aspx" target="_blank">qui</a>, cioè fondamentalmente dalla necessità di snellire la realizzazione di un’applicazione fortemente basata su M-V-VM e dalla necessità, evidenziata <a href="http://blogs.ugidotnet.org/topics/archive/2009/08/25/conversazione-ldquonon-solo-overviewrdquo-ltsemi-cit.gt.aspx" target="_blank">qui</a> e <a href="http://blogs.ugidotnet.org/topics/archive/2009/08/30/wrappa-che-ti-passa-ldquohow-to-in-salsa-tddrdquohellip.aspx" target="_blank">qui</a>, di fornire una UX che sia decisamente consistente. In questa direzione, e al crescere dell’applicazione, risulta rapidamente evidente che vi è la necessità di snellire e automatizzare il maggior numero possibile di task: quindi, come scegliamo di utilizzare un ORM (nel mio caso <a href="https://www.hibernate.org/343.html" target="_blank">NHibernate</a>) ha molto senso scegliere di utilizzare un toolkit (nel mio caso il mio :-), ma anche Prism v2 o Caliburn) per realizzare tutte quelle parti che altrimenti cuberebbero e occuperebbero la stragrande maggioranza del tempo di sviluppo distogliendoci dal problema di business.</span><br>  <span>Se sviluppate applicazioni desktop vi rendete rapidamente conto di come la UX diventi alla svelta il nodo centrale e il <em>succhia tempo</em> per eccellenza, però scoprite anche che avete un potenziale vantaggio: la UX sta in “cima” all’applicazione ed è l’unica cosa a diretto contatto con l’utente è quindi il vostro “<em>abito</em>” ma è anche un vantaggioso punto prestazionale perchè li il collo di bottiglia è l’utente che ha un concetto di prestazioni decisamente diverso dal nostro (e per molti versi difficilmente comprensibile da un tecnico) ma sopratutto è tutto tranne che prestazionale (l’utente). La UX è quindi un area in cui soluzioni basate sull’automazione possono essere accettabilissime anche se comportano un possibile problema prestazionale, in questo caso il nostro giudice è fortunatamente diverso da uno <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx" target="_blank">Stopwatch</a> ;-)</span><br>  <span><strong>Memento</strong></span><br>  <span>Il concetto di memento è decisamente importante per l’utente non molto per “noi”, noi inteso come parte core dell’applicazione, perchè dal punto di vista dei dati ha senso il tutto o niente (aka transazione) e non il <em>qualcosa</em> :-)</span><br>  <span>Il problema che però dobbiamo affrontare non è di facile soluzione. Come al solito partiamo con il guardarci in giro e in questo caso un ottimo candidato è un wordprocessor, quello che ci interessa è infatti essere in grado di supportare l’agognato ctrl+z/ctrl+y abbiamo però un inghippo, tanto per cambiare, noi abbiamo a che fare con un grafo eterogeneo di oggetti:</span><br>  <blockquote>   <span>il nostro (aka l’utente) esegue una ricerca, visualizza la sua bella lista di risultati e sceglie una anagrafica cliente da modificare, cambia la ragione sociale, modifica l’indirizzo del sito web, aggiunge un indirizzo, modifica una delle condizioni di pagamento predefinite, elimina una coordinata bancaria… poi simpaticamente fa: ctrl+z, e giustamente si aspetta di fare roolback dell’ultima cosa modificata, e poi ancora e ancora, e ancora una volta ma poi si accorge che l’ultimo <em>undo</em> non era cosa da farsi e quindi ctrl+y => <em>redo</em>.</span><br> </blockquote>  <span>in soldoni vuole questo:</span><br>  <span><a href="https://lh5.googleusercontent.com/-33I4X7qo_OQ/TyvMkJ3lOWI/AAAAAAAAAv8/txXdAEe_NyI/image_6.png" rel="lightbox"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="https://lh3.googleusercontent.com/-_46IJNHXdRU/TyvMjBhPEOI/AAAAAAAAAv4/EawNb7VeXM0/image_thumb_2.png" width="244" height="116"></a> </span><br>  <span>vuole poter <em>navigare</em> uno stack di modifiche avanti e indietro senza limiti di sorta e, giustamente, si aspetta che le modifiche si propaghino al grafo anche perchè per lui non è un grafo ma è semplicemente la scheda dell’anagrafica cliente.</span><br>    <span>Ok, se caliamo la cosa su un singolo oggetto è concettualmente abbastanza semplice, magari tecnicamente no, ma non è questo il problema adesso, perchè possiamo immaginarci un banale Stack, interno all’oggetto, in cui l’oggetto stesso “impila” le modifiche mano a mano che vengono apportate e ne gestisce lo stato di Undo/Redo. La cosa si complica un po’ se propaghiamo il tutto ad un grafo perchè risulta sin da subito evidente che è impossibile gestire la cosa internamente agli oggetti pena la pedita di sequenzialità delle operazioni nel momento in queste “spannano” sull’intero grafo in maniera casuale.</span><br>  <span>Abbiamo quindi bisogno di un terzo attore, un qualcosa che esternamente faccia da repository per lo stack delle modifiche e a cui gli oggetti del grafo possano agganciarsi per eseguire il trace dello loro stato. E’ altrettanto evidente che questa cosa non possa in nessun modo essere implementata sulle nostre entità di dominio, ma debba essere delegata al <a href="http://blogs.ugidotnet.org/topics/archive/2009/08/30/wrappa-che-ti-passa-ldquohow-to-in-salsa-tddrdquohellip.aspx" target="_blank">mediatore che sta tra il dominio e lo screen di editing</a>.</span><br>  <span>Per ora quindi quello che possiamo asserire è che ci servono:</span><br>  <ol>   <li>Un gestore superpartes delle modifiche che sia in grado di tenere traccia, anche temporalmente, di quello che succede; </li>    <li>Un qualcosa che incapsuli, in maniera generica e condivisa dal gestore, il concetto di <em>pending change</em>; </li>    <li>Un modo <u>semplice</u> per agganciare/sganciare un <u>grafo</u> di oggetti al gestore di cui sopra; </li> </ol>  <span>Buon weekend :-)</span><br>  <span>.m</span><br>

---
layout: post
title: TechEd Developer - WF Drop in clinic WD
date: '2006-11-09T11:07:00.000+01:00'
author: Mauro Servienti
tags:
- Why not...
modified_time: '2012-01-25T21:24:38.347+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-3439000576627775423
blogger_orig_url: http://milestone.topics.it/2006/11/teched-developer-wf-drop-in-clinic-wd.html
permalink: /2006/11/teched-developer-wf-drop-in-clinic-wd.html
---

<span>Paul Andrew e Matt Winkler - Q&A Session</span><br> <span>Ho fatto anche io la mia domanda :-D</span><br> <span>- best practice to impletment "go-to", mutuata da un po' di elucubrazioni con Raffaele</span><br> <span>Sulla lavagna per ora ci sono un sacco di domande la cosa si fa interessante...</span><br> <span><em>Hosting designers vs building your own designer</em><br>Suggeriscono di costruire il ptoptio deisgner piuttosto che ostare quello fornito perchè è dev oriented e non end user oriented</span><br> <span><em>XAML vs Code Behind</em><br>Se l'uso del solo XAML permette di persistere lo schema del workflow pressochè ovunque e di conseguenza di modificarlo molto facilmente non ci permette facilmente di benificiare di tutti i vantaggi del code behind uno su tutti le CodeActivity o le Custome Properties all'interno del Workflow</span><br> <span><em>Migrating from exixting formats</em><br>Nulla di più semplice, si fa per dire. C'è la possibiolità di pluggare un proprio Loader per eseguire il parsing del proprio formato e costruire l'albero delle Activity</span><br> <span><em>Dynamic updating existing and running Workflows</em><br>Sembra la cosa più facile di questa terra... ma non è proprio così comunque l'unico requisito è che il Workflow sia un "suspend state", c'è anche la possibilità di modificare via CodeDom del codice all'interno ad esempio di una CodeActivity... una nota importante è che le performance NON ci sono proprio, ma del resto stiamo facendo qualcosa di decisamente "tosto" ;-)</span><br> <span><em>Custom Persistance Provider Service</em><br>Semplicemente suggeriscono di guardare gli esempi presenti nel Windows SDK</span><br> <span><em>Scalbility with 100k instances running</em><br>Non è un problema perchè ci basta implementare una buona politica di persistenza quando il WF è on "idle state", il problema si pone se fossero tutti running ma comunque ci penserebbe il ThreadPool ad acccodarli in modo da non satuirare le risorse.<br>Se parliamo invece di scalabilità la cosa si fa un po' più tosta ma il problema si sposta sulla gestione dei messaggi in ingresso, è quindi possibile ad esempio avere un Front-End che fa poi dispatch dei messaggi in ingresso verso una batteria di server in load balancing che accedono tutti ad un Cluster di Sql Server per lostaorage implementando un proprio meccanismo di locking per controllare la concorrenza sugli eventualei WF running...</span><br> <span><em>Compensation</em><br>Bell'esempio su come implementare ICompasatableActivity in una proprio Custom Activity per gestire il roolback in uno scerario si transazionale ma non basato su locking come invece è una transazione tradizionale</span><br> <span><em>Go-To</em><br>Ritengono che la soluzione migliore sia quella di implemenatere un proprio tipo di WorkFlow, anche se una soluzione c'è usando uno "State Machine Workflow" che comunque non è la soluzione definitiva, all'interno del proprio tipo implementare delle Custom Activity che consentano di "saltare indietro" verso uno step precedente, certo che non è proprio una cosa banale ;-)</span><br> <span>Molto ma molto interessante, bella questa sessione, è proprio un bel format.</span><br> <span>.m</span><br>

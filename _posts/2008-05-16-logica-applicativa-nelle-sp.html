---
layout: post
title: Logica applicativa nelle SP...?
date: '2008-05-16T10:40:00.000+02:00'
author: Mauro Servienti
tags:
- Why not...
- Software Mason
- Architecture
modified_time: '2012-02-08T06:37:53.358+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-8344687189080945627
blogger_orig_url: http://milestone.topics.it/2008/05/logica-applicativa-nelle-sp.html
---

<span>...lungi da me ;-), ma... ebbene si secondo me c'è sempre un ma.</span><br>  <span>In questo periodo, decisamente massacrante, stiamo <a href="http://blogs.ugidotnet.org/topics/archive/2008/05/01/offerta-di-lavoro.aspx" target="_blank">lavorando ad una soluzione</a> potenzialmente abbastanza complessa e potenzialmente <em>molto</em> distribuita ;-) quindi uno dei problemi è che abbiamo <em>n</em> tier che vengono coinvolti dal ciclo di vita di una entity o da una operazione di business; e questo mi fa sempre dire che ogni tier/layer è storia a se, non sa nulla di chi sta prima e sa molto poco di chi sta dopo... e se assieme a questo assioma ci mettiamo che il dato è sacro (meglio un <em>service unavailable</em> che una <em>information disclosure, <a href="http://blogs.msdn.com/michael_howard/" target="_blank">qualcuno</a> disse: "it sucks, but it sucks less"</em>) allora è facile asserire e sostenere che, ad esempio, i controlli sulla validità del dato in ingresso <u>devono</u> essere fatti a qualsiasi livello e siccome uno di questi livelli è il database io ce li metto pure li.</span><br>  <span>.m</span><br>  <span><em><update></em>    <br>A seguito del commento di Igor forse è giusto che faccia un approfondimento. Quando dico che il dato è sacro intendo dire che è sacro per ogni tier a modo suo. Ogni tier ha una sua visione del dato e ha un suo modo per ritenerlo valido, quindi ha una sua logica di validazione che è decisamente diversa da tier a tier. Questo significa che se la business rule dice che il "Cognome" non deve essere più di x caratteri è un problema applicativo e al db non interessa minimamente mentre al db ad esempio interessa e molto che il dato che arriva non corrompa lo consistenza dei dati che già sono presenti, e di certo un Cognome troppo lungo non corrempe un bel nulla ;-)</span><br>  <span>Un'altro apsetto fondamentale di tale logica è ad esempio la validazione dei parametri/argomenti di un metodo, come lo faccio nel mio codice C# lo faccio anche nel codice T-Sql. E qui non c'è santo che tenga se una enumerazione può assumere 3 valori devo controllare che quello che arriva sia consistente.</span><br>  <span>Dipende tutto dal punto in cui ci si trova a guardare il flusso.</span><br>  <span>Resta il fatto che se hai un'applicazione distribuita devi prevedere che ci possa essere il "<em>furbetto</em>" che cerca di chiamarti direttamente il servizio WCF passando dei dati malformati solo per il gusto di vederlo schiantare.</span><br>  <span>per quel che riguarda infine le business rules tendo a centralizzare molto, una cosa del tipo:</span><br>  <span>IServiceContainer sc = ServiceContainer.GetContainer();   <br>using( IValidationService svc = sc.GetService<IValidationService>() )    <br>{    <br>    IValidationContext ctx = MyEntityValidationContext( entity, action, bla, bla, bla );    <br>    IValidationResult result = svc.Validate( ctx );    <br>}    <br><em></update></em></span><br>  
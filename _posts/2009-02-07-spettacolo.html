---
layout: post
title: Spettacolo!
date: '2009-02-07T16:12:00.000+01:00'
author: Mauro Servienti
tags:
- WPF
- Software Mason
- Architecture
- Model View ViewModel
- Inversion of Control
modified_time: '2012-01-31T14:02:24.652+01:00'
thumbnail: https://lh6.googleusercontent.com/-Q8Gba0lKrzs/TyfmWdHhiNI/AAAAAAAAAT0/n-y1ot6rh6g/s72-c/image_thumb.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-912987356328627044
blogger_orig_url: http://milestone.topics.it/2009/02/spettacolo.html
permalink: /2009/02/spettacolo.html
---

<span>Era un po’ di tempo che non mi divertivo così tanto a fare questo lavoro!</span><br>  <span>Da un mesetto a questa parte sto lavorando ad un nuovo progetto che è nato quasi per caso.</span><br>  <span>In dicembre <u>IL</u> mio cliente storico si presenta e mi dice che avrebbero bisogno di una semplice applicazione per fare l’inventario di una delle loro attività al pubblico.</span><br>  <span>L’obiettivo è quello di avere uno strumento snello e semplice che permetta ad <em>n</em> operatori di lavorare insieme e funzioni senza fronzoli e soprattutto senza problemi dato che il tempo stimato per l’inventario è di 72h e l’attività commerciale non deve restare ferma di più. Al termine sarà onere di chi gestisce il sistema informativo di quell’attività sincronizzare i dati di inventario con l’infrastruttura esistente.</span><br>  <span>Quindi sintettizzando:</span><br>  <ul>   <li>pochi fronzoli; </li>    <li>user frendly spintissimo; </li>    <li>ciclo di vita brevissimo (72h); </li>    <li>Tempo disponibile per la realizzazione 5gg, l’inventario sarebbe inizato la settimana dopo; </li> </ul>  <span>Dopo una breve analisi la scelta è stata:</span><br>  <ul>   <li>disegno il mio modello fatto di interfacce; </li>    <li>scrivo una suite di test che, grazie a un po’ di Stub e Mock, mi aiuta a capire che il modello sta insieme e mi piace; </li>    <li>Implemento il modello e per la parte DAL/Repository scelgo Linq2Sql: produttività da paura; </li>    <li>faccio una scelta azzardata e decido di utilizzare, per la UI, WPF (di cui so poco e nulla); </li> </ul>  <span>I primi tre punti vanno via lisci, il quarto, sgomitando un bel po’ tra San Google e <a href="http://blogs.ugidotnet.org/corrado" target="_blank">San Corrado</a>, a cui va tutta la mia ammirazione per avermi supportato ma soprattutto sopportato…, va via altrettanto liscio… e voi direte ma che ce frega ma che ce importa!?!? adesso arriva il bello, pazienza ;-)</span><br>  <span>Siccome i primi 3 punti, grazie a un po’ di TDD ad una suite di test decente e ad un po’ di olio di gomito, li sbologno in 1 giorno e mezzo mi restano ancora 3 giorni abbondanti per la UI, su suggerimento di Corrado vado di Model-View-ViewModel e dopo un giorno di s*ado*nam*nti vari con xaml comincio a prenderci gusto e in perfetto orario dopo 3 giorni consegno la mia bella applicazione, facciamo l’inventario e tutto fila liscio come non mi sarei mai aspettato.</span><br>  <span>Un po’ di considerazioni sparse:</span><br>  <ul>   <li>WPF: <u>Spettacolo</u>! potenza e libertà infinite; </li>    <li>Cider: <a href="http://idioms.thefreedictionary.com/pain+in+the+ass" target="_blank">a pain in the ass</a>, non dico altro;       <ul>       <li>Disabilitare al volo il designer e passare alla visualizzazione diretta dell xaml è un must; </li>        <li>Alla fine addomesticare xaml, anche grazie al supporto notevole dell’IntelliSense di Visual Studio, non è poi così difficile; </li>        <li>Scrivere una Window come si faceva nella preistoria con l’HTML (blocco note + markup + fervida immaginazione) non è poi molto difficile… certo il markup di xaml è un <em>filino</em> più esteso di quello di HTML… ;-) </li>     </ul>   </li>    <li>Expression Blend: molto utile, ma non fondamentale secondo me, diventa utile quando devi fare cose che l’immaginazione fa fatica a capire cosa/come saranno… o effettivamente quando cominci ad avere a che fare con animazioni, template, styling e tutte quelle belle funzionalità avanzate di WPF ma se vi limitate ad un’interfaccia Windows Form Like non è vitale; </li>    <li><strong>M</strong>odel-<strong>V</strong>iew-<strong>V</strong>iew<strong>M</strong>odel: manna dal cielo. M-V-VM unito alla potenza enorme del databinding di WPF è semplicemente spettacolare, permette due cose importanti:       <ul>       <li>Testing della <u>logica</u> della UI: ci tengo a sottolineare della logica perchè se poi mi dimentico di mettere in binding un command con un elemento della UI non è che ci possa fare molto… è vero si può fare il testing della UI/View stessa ma io sono ancora scettico e secondo me il gioco non vale la candela almeno non ancora perchè gli strumenti non sono ancora maturi; </li>        <li>Separation of Concern: rimpiazzare completamente il look&feel dell’applicazione, o meglio ancora farlo fare ad altri è sempre più un gioco da ragazzi… <em>more on this later</em> ;-) </li>     </ul>   </li> </ul>  <span>A seguito dell’inventario quello che succede è che chi gestisce il sistema si “rifiuta” (il rifiuta è un termine un po’ troppo forte ed è una lunga storia con un sacco di buone ragioni, ma ci ha comunque colto un po’ alla sprovvista) di adoperarsi per l’integrazione dei dati dell’inventario… panico!</span><br>  <span>Decidiamo allora, con solo 24h alla riapertua ufficiale, fortunatamente è festa, di investire sul prodottino che abbiamo usato per fare l’inventario e fare il possibile per rendere operativi gli operatori con le funzionalità indespensabili.</span><br>  <span>Spettacolo 2° atto.</span><br>  <ul>   <li>Avendo fatto uso massiccio di un framework di IoC diventa molto facile introdurre nel modello nuovi servizi e nuove entità; </li>    <li>Essendoci una discreta batteria di test il cambiamento massiccio viene affrontato con una discreta sicurezza; </li>    <li>L’uso di M-V-VM dimostra la sua potenza spettacolare perchè il refactoring della UI per passare dalla UI a senso unico ad una multi purpose è veramente facile, quasi disarmante; </li> </ul>  <span>In 16h realizziamo qualcosa di utilizzabile talmente ben riuscito che decidiamo di andare avanti…</span><br>  <span>Spettacolo 3° atto.</span><br>  <span>A questo punto il problema è che l’applicazione, che era nata con un unico scopo, deve diventare un gestionale, si… mono prodotto, ma… con tutti i crismi. Non solo l’inghippo vero e proprio è che praticamente siamo, nostro malgrado, in produzione in un’attività aperta al pubblico dove non è proprio semplice dire “ooops” abbiamo sbagliato dobbiamo fermarci un attimo… perchè non abbiamo uno stage di test. Stimolante :-D</span><br>  <span>Tutto ciò mi conferma che IoC/DI sono <strong>la</strong> flessibilità in assoluto introdurre nuovi servizi/entità cambiare le relazioni e le “dipendenze” è decisamente facile.</span><br>  <span>Il problema a cui mi sono trovato di fronte è però stato, e lo è tutt’ora perchè siamo in continuo divenire, lato presentation perchè la filosofia generale che ho seguito, Separation of Concern, rende abbastanza complesso l’approccio alla UI. Vediamo un esempio chiarificatore:</span><br>  <span><a href="https://lh6.googleusercontent.com/-wHY7awjz0UU/TyfmWpbE9mI/AAAAAAAAAUA/tuJCvuMffMk/image_2.png" rel="lightbox"><img title="image" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="144" alt="image" src="https://lh6.googleusercontent.com/-Q8Gba0lKrzs/TyfmWdHhiNI/AAAAAAAAAT0/n-y1ot6rh6g/image_thumb.png" width="244" border="0"></a> </span><br>  <span>Il modello M-V-VM molto semplicemente mette un attore, il ViewModel, tra il modello e la view, questo attore ha una dipenedenza anche dagli eventuali servizi e li sfrutta per dialogare e/o manipolare il modello. Quel diagramma sembra semplice ma se cominciamo a pensare ad un’applicazione reale in cui probabilmente c’è più di una finestra la cosa si complica un filino ma comunque resta abbastanza semplice perchè ci basta introdurre un servizio di navigazione (INavigationService) che conosce la struttura dell’applicazione, le modalità di navigazione etc etc..</span><br>  <span>Ma…, perchè c’è sempre un ma…il bello del nostro lavoro :-D, complichiamoci ancora un po’ la vita e pensiamo ad un’applicazione veramente reale, una che abbiamo <em>sottoledita</em> tutti i giorni: Visual Studio.</span><br>  <span>La UI è decisamente complessa e le “regole” di M-V-VM ci dicono che ogni parte (teniamo a mente il termine “region”) della UI dovrebbe avere un corrispondente ViewModel ma qesto ci mette un po’ in crisi perchè le varie parti della UI/ViewModel molto probabilmente hanno bisogno di comunicare tra di loro… e qui siamo un po’ in croce perchè un “errore” che potremmo essere portati a fare, io l’ho fatto, è questo:</span><br>  <span><a href="https://lh6.googleusercontent.com/-Ksh0-w1n7BQ/TyfmXxoXBQI/AAAAAAAAAUM/WBdn9UkTJeA/image_4.png" rel="lightbox"><img title="image" style="border-top-width: 0px; display: inline; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="106" alt="image" src="https://lh3.googleusercontent.com/-6h8gXdQVkdA/TyfmXcuCK1I/AAAAAAAAAUE/FEcus7zJLbQ/image_thumb_1.png" width="244" border="0"></a> </span><br>  <span>Il modello <u>puzza</u> già di suo ma nonostante tutto funziona, il problema però è grosso e si rende evidente al primo refactoring della UI. Una delle cose veramente potenti di Model-View-ViewModel è che rende totalmente indipendenti il look & feel dell’applicazione dalla logica su cio quel look & feel insiste. Per capirci: il ViewModel espone un “SaveCommand” e per lui è del tutto irrilevante di come la UI decida di presentare la funzionalità all’utente. Un esempio chiarificatore sta proprio nella UI di Visual Studio, il comando “Save All” appartiene alla finestra principale di VS ma quel comando si occupa di salvare “documenti” che non stanno, dal punto di vista logico, nella finestra principale se adottiamo una gerarchia di ViewModel (come nel diagramma di prima) risolviamo ma rendiamo dipendenti i “documenti” dalla finestra principale perchè la finestra principale deve conoscere l’esistenza dei documenti per poter invocare il comando “Save”. Diventa a questo punto evidente che se spostiamo i documenti siamo obbligati ad informare la finestra principale pena la pedita di funzionalità… male molto male.</span><br>  <span>Se sopra tutto ciò ci mettiamo la velleità di avere un sistema estendibile via add-in/package allora crolla proprio tutto molto alla svelta.</span><br>  <span>Soluzioni naturalmente ce ne sono, anche di già pronte, come ad esempio <a href="http://www.codeplex.com/caliburn" target="_blank">Caliburn</a> e <a href="http://www.codeplex.com/CompositeWPF" target="_blank">PRISM</a> ma entrambe sono decisamente complesse e mi privano della mia irrefrenabile necessità di capire, quindi prima di tutto devo trovare la soluzione da me poi valuteremo se adottare una soluzione “boxed”.</span><br>  <span>Dato per assodato che M-V-VM non si tocca adesso abbiamo ancora 2 problemi da risolvere:</span><br>  <ul>   <li>Comunicazione tra i ViewModel: non potendo avere una gerarchia di ViewModel, perchè è troppo fragile, e dovendo quindi tener separti nettamente i ruoli abbiamo il problema di come far comunicare i vari moduli (aka Module) dell’applicazione; </li>    <li>Flessibilità della UI: una UI complessa come quella di Visual Studio è composta da parti (Region) che sono molto flessibili e difficilmente gestibili con un semplice NavigationService; </li> </ul>  <span>Vi dico subito che il secondo problema non l’ho ancora affrontato perchè non è tra le mie priorità, mentre il primo si è posto proprio qualche giorno fa proprio a seguito della necessità di fare un massiccio refactoring della UI ridistribuendo e rivoluzionando le funzionalità a disposizione.</span><br>  <span>La cosa è stata brillantemente, si me la tiro :-D, realizzando un semplice message broker basato sul modello publisher/subscriber, che è poi la tecnica, anche se con funzionalità decisamente più complesse, che usano i due blasonati framework che ho citato.</span><br>  <span>Ogni ViewModel ha (o può avere) una dipendenza da un servizio, grazie <em>IoC</em>!!, di <em>borkering</em> IMessageBroker e può usarlo per “postare”, IMessageBroker.Post<T>( T message ), mentre un altro ViewModel può decidere di fare la subscription ad un determinato messaggio, IMessageBroker.Subscribe<T>( Object subscriber, Action<T> callback ), e attendere che qualcuno pubblichi qualcosa… semplice, funziona e funziona pure un gran bene disaccoppiando complemente i vari ViewModel e permettendoci di fare tutto il refactoring che vogliamo.</span><br>  <span>Anche per stavolta vi ho tediato abbastanza… :-D, avrei un’altra montagna di cose da dire anche molto tecniche, sarà per la prossima volta. Ci tengo però ha sottolineare che ho imparato qualcosa di nuovo, oltre alle novità squisitamente tecniche: <u>fai quello che serve (punto), frena il tuo ego :-D</u></span><br>  <span>Io adoro questo lavoro!</span><br>  <span>.m</span><br>  

---
layout: post
title: 'Compensazione: bozze + pubblicazione transazionale'
date: '2011-06-30T09:00:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- Wcf
modified_time: '2012-08-04T19:54:19.186+02:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-1726212967231292109
blogger_orig_url: http://milestone.topics.it/2011/06/compensazione-bozze-pubblicazione.html
---

<span>abbiamo <a href="http://mauroservienti.blogspot.com/2011/06/un-mondo-di-servizi-che-devono-essere.html" target="_blank"><em>blaterato</em></a> di servizi WCF e ad un certo punto abbiamo parlato di compensazione, più che parlato abbiamo buttato li la cosa senza approfondire.</span><br>  <span><strong>Che cavolo stai dicendo Willis?</strong> <cit.></span><br>  <span>Un processo compensativo è necessario quando non è possibile, oppure è insensato, pensare ad una transazione (nel senso ACID del termine); una casistica?</span><br>  <blockquote>   <span>Pensiamo ad un long-running-workflow, come ad esempio una commessa per la costruzione di una nave, non è pensabile avviare una transazione al momento T0 e farne il commit 2 anni dopo, ma è comunque necessario trovare un sistema per fare una <em>sorta</em> di rollback delle operazioni anche a distanza di tempo.</span><br> </blockquote>  <span>è quindi necessario <u>compensare</u> gli effetti di qualcosa che è già avvenuto che è ben diverso dal fare il rollback di una transazione che rappresenta un qualcosa che ancora non è avvenuto.</span><br>  <span>Avete generalmente due scenari:</span><br>  <ul>   <li>dovete introdurre un processo compensativo a posteriori (tipicamente perché avete progettato male);</li>    <li>dovete pensare un processo compensativo up-front tipicamente perché i dati che manipolate sono distribuiti su basi dati eterogenee su cui non è possibile avere una transazione distribuita (o come abbiamo già avuto modo di dire su cui non ha nessun senso avere una transazione distribuita);</li> </ul>  <span>l’altra volta abbiamo detto:</span><br>  <blockquote>   <span>…Sta di fatto che l’atomicità (o presunta tale) dell’operazione la dobbiamo garantire, se non altro perché l’utente si aspetta che se ha uno screen in cui può <u>creare un Employee, assegnarvi un Address e un Department</u> e sullo screen c’è un singolo pulsante salva, il nostro simpatico utente si aspetta che quell’operazione sia atomica, quindi se l’assegnazione dell’Address fallisce non è concepibile che l’Employee esista (punto-fine-della-discussione)…</span><br> </blockquote>  <span>Supponiamo che abbiate un servizio che gestisce questa logica, ed esponga le 3 operazioni descritte, le tre operazioni ovviamente non sono atomiche, o meglio prese singolarmente si, ma nel loro insieme no; il sistema è in produzione ed è decisamente ostico cambiare radicalmente l’API pubblica per adeguarla in base alle esigente. Questo è un tipico scenario in cui potrebbe aver senso introdurre un processo compensativo basato sulla pubblicazione.</span><br>  <span>Andiamo un più nel dettaglio del sistema: dietro il servizio WCF c’è un Object Model mappato su un database relazionale con tutti i suoi, sacrosanti, criteri di integrità referenziale.</span><br>  <span>Potete quindi procedere ad esempio così:</span><br>  <ul>   <li>introdurre sul modello (e quindi nel database) il concetto di <em>IsPublished</em>, che di default è <em>false</em>;</li>    <li>adattare tutti i processi di lettura per estrarre solo i dati che hanno <em>IsPublished</em> impostato a <em>true</em>;</li> </ul>  <span>Fino a questo punto i sistemi esterni non si sono accorti di nulla e continuano a funzionare, in lettura, esattamente come prima;</span><br>  <ul>   <li>aggiungere un’operazione <em>Publish</em> che dato un set di identificatori sia in grado, in maniera transazionale, di cambiare lo stato <em>IsPublished</em> di tutte le entità identificate dal set in un colpo solo;</li> </ul>  <span>in scrittura invece succede che apparentemente non scriviamo più nulla, chiamiamo le operazioni sul servizio ma questa sembrano non sortire effetti, ma se al termine di ogni set di operazioni aggiungiamo una chiamata a <em>Publish</em> tutto torna a funzionare come prima.</span><br>  <span><strong>Quale è il vantaggio?</strong></span><br>  <span>Molto semplicemente siamo in grado di compensare una <em>failure</em> in un processo che dovrebbe essere atomico ma che purtroppo non lo è. Nella peggiore delle ipotesi se durante il processo di creazione del grafo qualcosa va storto abbiamo degli elementi esistenti ma non pubblicati che quindi è come se non esistessero.</span><br>  <span>.m</span><br>
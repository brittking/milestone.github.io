---
layout: post
title: UserPrincipal.GetAuthorizationGroups()…oh my!
date: '2012-12-11T09:09:00.000+01:00'
author: Mauro Servienti
tags:
- Software Mason
modified_time: '2012-12-11T09:09:00.034+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-157364087635693329
blogger_orig_url: http://milestone.topics.it/2012/12/userprincipalgetauthorizationgroupsoh-my.html
---

<h2>The problem</h2> <p>There is a really <a href="http://msdn.microsoft.com/EN-US/library/bb340590(v=VS.110,d=hv.2).aspx" target="_blank">convenient method</a> that can be used to retrieve a flat list of <strong>all</strong> the groups (event nested) given a known UserPrincipal, e.g. the current user, the really amazing thing is that the method saves you from doing a group recursion to retrieve the groups relationships in order to detect that a user belongs to a group A that belongs to a group B.</p> <p>The above method utilizes, as far as I know, the security tokens attached to a given user principal and then resolves the group names given the group SID.</p> <p>The problem is that that method can fail with a really strange exception “<a href="http://msdn.microsoft.com/EN-US/library/bb336570(v=VS.110,d=hv.2).aspx" target="_blank">NoMatchingPrincipalException</a>” (the group cannot be found) that is typically related to 2 different scenarios:</p> <ol> <li>One, or more, of the group has <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679833(v=vs.85).aspx" target="_blank">SID History</a> enabled;</li> <li>In a complex domain topology one of the DC is not available at the moment of the query;</li></ol> <p>To make a long story short: we simply cannot rely on that method, period.</p> <h2>The solution</h2> <blockquote> <div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">IEnumerable&lt;String&gt; GetGroups( String samAccountName )<br>{<br>    var userNestedMembership = <span style="color: #0000ff">new</span> List&lt;<span style="color: #0000ff">string</span>&gt;();<br><br>    var domainConnection = <span style="color: #0000ff">new</span> DirectoryEntry();<br>    domainConnection.AuthenticationType = System.DirectoryServices.AuthenticationTypes.Secure;<br><br>    var samSearcher = <span style="color: #0000ff">new</span> DirectorySearcher();<br><br>    samSearcher.SearchRoot = domainConnection;<br>    samSearcher.Filter = <span style="color: #006080">"(samAccountName="</span> + samAccountName + <span style="color: #006080">")"</span>;<br>    samSearcher.PropertiesToLoad.Add( <span style="color: #006080">"displayName"</span> );<br><br>    var samResult = samSearcher.FindOne();<br><br>    <span style="color: #0000ff">if</span> ( samResult != <span style="color: #0000ff">null</span> )<br>    {<br>        var theUser = samResult.GetDirectoryEntry();<br>        theUser.RefreshCache( <span style="color: #0000ff">new</span> <span style="color: #0000ff">string</span>[] { <span style="color: #006080">"tokenGroups"</span> } );<br><br>        <span style="color: #0000ff">foreach</span> ( <span style="color: #0000ff">byte</span>[] resultBytes <span style="color: #0000ff">in</span> theUser.Properties[ <span style="color: #006080">"tokenGroups"</span> ] )<br>        {<br>            var SID = <span style="color: #0000ff">new</span> SecurityIdentifier( resultBytes, 0 );<br>            var sidSearcher = <span style="color: #0000ff">new</span> DirectorySearcher();<br><br>            sidSearcher.SearchRoot = domainConnection;<br>            sidSearcher.Filter = <span style="color: #006080">"(objectSid="</span> + SID.Value + <span style="color: #006080">")"</span>;<br>            sidSearcher.PropertiesToLoad.Add( <span style="color: #006080">"name"</span> );<br><br>            var sidResult = sidSearcher.FindOne();<br>            <span style="color: #0000ff">if</span> ( sidResult != <span style="color: #0000ff">null</span> )<br>            {<br>                userNestedMembership.Add( ( <span style="color: #0000ff">string</span> )sidResult.Properties[ <span style="color: #006080">"name"</span> ][ 0 ] );<br>            }<br>        }<br>    }<br><br>    <span style="color: #0000ff">return</span> userNestedMembership;<br>}</pre><br></div></blockquote>
<p>A bunch of old good directory services related code :-) where the really really really, have I said really?, important piece is the following:</p>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">theUser.RefreshCache( <span style="color: #0000ff">new</span> <span style="color: #0000ff">string</span>[] { <span style="color: #006080">"tokenGroups"</span> } );</pre><br></div></blockquote>
<p>That asks to the underlying system to refresh the cache of the groups security tokens attached to the given user.</p>
<p>.m</p>  
---
layout: post
title: 'UI Composition :: La Shell'
date: '2009-03-31T03:46:00.000+02:00'
author: Mauro Servienti
tags:
- Architecture
- UI Composition
modified_time: '2012-01-31T14:03:41.885+01:00'
thumbnail: https://lh4.googleusercontent.com/-GInD634JnF0/TyfmpNpEeeI/AAAAAAAAAWE/tDWI8ZRsU_A/s72-c/image_thumb.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-3842884584164874321
blogger_orig_url: http://milestone.topics.it/2009/03/ui-composition-la-shell.html
permalink: /2009/03/ui-composition-la-shell.html
---

<span><em>Here we are, lets go deeper!</em></span><br>  <span>Concentriamo in questo post i primi 2 argomenti:</span><br>  <ul>   <li>L’organizzazione della solution in Visual Studio, e i problemi che ci dobbiamo portare a casa; </li>    <li>La Shell: lo scheletro della nostra infrastruttura; </li> </ul>  <span><strong>Visual Studio: how to…</strong></span><br>  <span>L’organizzazione della solution in VS è fondamentale per non impazzire durante lo sviluppo e per supportare sia i vostri requisiti sia l’infrastruttura di IoC; quest’ultima è quella che rende particolarmente critica la struttura della solution:</span><br>  <span><strong>Dogma</strong>: un framework non deve dipendere da un IoC container;</span><br>  <span>L’introduzione di IoC comporta che quello che prima veniva realizzato con un singolo progetto di Visual Studio adesso venga realizzato con 2 progetti (minimo):</span><br>  <ul>   <li><u>Contracts</u>: un progetto contiene i soli contratti (interface(s)) pubblici e sarà questo progetto/assembly a cui gli altri avranno una reference; </li>    <li><u>Runtime</u>: un progetto contiene l’implementazione concreta dei contratti, questo progetto non è “noto” a nessuno se non alla configurazione del framework di IoC; </li> </ul>  <span>Questa separazione porta ad un problema:</span><br>  <span><a href="https://lh4.googleusercontent.com/-NxQEgS5_Emo/TyfmpjqiT7I/AAAAAAAAAWM/JMJ3D0VgrZQ/image_2.png" rel="lightbox"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="https://lh4.googleusercontent.com/-GInD634JnF0/TyfmpNpEeeI/AAAAAAAAAWE/tDWI8ZRsU_A/image_thumb.png" width="244" height="108"></a> </span><br>  <span>L’applicazione ha una reference alla parte dei contratti ma a runtime avete bisogno che l’implementaziuone concreta dei contratti si trovi all’interno della “Bin” dell’applicazione… altrimenti scoppia tutto, ci sono svariate soluzioni a questo inghippo.</span><br>  <span>La più bella, ma anche complessa, passa dalla realizzazione di un Task per MSBuild e in questo caso non ha molto senso, forse… A noi basta semplicemente una “post build action” che copi il contenuto della Bin della parte “runtime” nella Bin dell’applicazione:</span><br>  <blockquote>   <span>copy "$(TargetDir)$(TargetName).*" "..\..\..\..\out\$(ConfigurationName)\$(TargetName).*" /B /Y</span><br> </blockquote>  <span>In realtà come si può intuire dal comando non facciamo proprio quello ma passiamo da un punto comune. Ergo dall’assembly “Runtime” al termine della compilazione copiamo il tutto in una directory “out\Debug”, ad esempio, e poi da una post buil action dell’applicazione facciamo il resto:</span><br>  <blockquote>   <span>xcopy "..\..\..\..\out\$(ConfigurationName)\*.*" "$(TargetDir)*.*" /Y /R</span><br> </blockquote>  <span>Questo doppio passaggio, nonostante all’apparenza si ridondante, risulta poi molto comodo perchè ci consente di avere la massima flessibilità nell’organizzazione su FileSystem della struttura della nostra solution, e vi garantisco che quando superate i 50 progetti la cosa diventa importante.</span><br>  <span>Perchè il tutto funzioni ci sono altri 2 vincoli, purtroppo:</span><br>  <ol>   <li>Dovete impostare manualmente le dipendenze (dx sulla Solution –> Project Depenedencies) al fine di garantirvi che i progetti vengano <em>buildati</em> nell’ordine corretto; se impostare le reference tra progetti questa cosa VS è in grado di farla da solo altrimenti, giustamente, no; </li>    <li>C’è poi la vera rottura che ogni compilazione dovrà essere una <u>Full Rebuild</u> della solution altrimenti le Post Build Action non vengono sempre onorate… in questo caso un task di MS Build sarebbe la manna sempre perchè quando superate i 50 progetti ogni rebuild è un delirio… </li> </ol>  <span>La mia scelta per l’organizzazione dei progetti su FileSystem è questa:</span><br>  <span><a href="https://lh4.googleusercontent.com/-5A0TI9P8P3Q/Tyfmq8sZ47I/AAAAAAAAAWY/yH0ily5Dpo8/image_6.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="https://lh6.googleusercontent.com/-FwurP1LSe6I/TyfmqUbFsUI/AAAAAAAAAWQ/MxZKJSpj0K8/image_thumb_2.png" width="198" height="244"></a> </span><br>  <span>Direi che non c’è nulla da spiegare, se avete domande fatele.</span><br>  <span><strong>IoC Integration</strong></span><br>  <span>Questa sezione non è strettamente necessaria, ma dipende molto dal vostro gusto personale e da quello che volete sfruttare di un framework di IoC.</span><br>  <span>Possiamo senza dubbio affermare che l’adozione di un framework di IoC tende ad essere <em>virale</em> per l’applicazione: con questo intendo dire che è decisamente arduo fare in modo che l’applicazione conosca un’astrazione del concetto di IoC al fine di rimpiazzare il toolkit.</span><br>  <span>La cosa è fattibile fintanto che del toolkit sfruttate “solo” (come se fosse poco) le funzionalità di Service Locator, Lifestyle management, Dependency Injection e poco altro… se però volete spingere al massimo il toolkit e scroccarne le funzionalità per fare AOP ad esempio allora non c’è nulla da fare astrarre il concetto è impossibile e l’adozione di un certo toolkit diventerà permanente.</span><br>  <span>Detto questo sta a voi decidere quale strada prendere. Ritengo che la scelta debba essere:</span><br>  <ul>   <li>Sto sviluppando l’applicazione allora mi va benissimo dipendere da un framework xyz, non lo vedo come un problema, anzi…; </li>    <li>Sto sviluppando un framework/toolkit non posso permettermi nessuna dipendenza perchè obbligherei l’utilizzatore del toolkit/fx alla stessa dipendenza, quindi se ho bisogno di un fx di IoC (e probabilmente è uno smell) allora devo astrarre. </li> </ul>  <span><strong>La Shell</strong></span><br>  <span>Finalmente! :-D</span><br>  <span>La Shell è il guscio/conchiglia che ospita la nostra applicazione, la Shell è composta come minimo da:</span><br>  <ul>   <li><u>Application</u>: l’applicazione è l’entry point, l’eseguibile che viene effettivamente lanciato. Qui non c’è nessuna logica semplicemente l’applicazione ha l’onere di “trovare” un’istanza di…</li>    <li><u>ApplicationBootstrapper</u>: l’appBootstrapper è il vero cuore dell’applicazione, i suoi compiti sono:</li>    <ul>     <li>configurare il service container registrando i servizi della shell e i servizi che saranno esposti dalla shell;</li>      <li>avviare il processo di discovery/inizializzazione/esecuzione dei moduli;</li>      <li>monitorare gli eventuali messaggi diretti all’applicazione: tipico esempio è una richiesta di shoutdown;</li>      <li>Infine avviare la shell vera e prorpia;</li>   </ul>    <li>La <u>Shell</u> è infine il componente visuale che ospiterà la nostra applicazione;</li> </ul>  <span>Inizialmente ero partito facendo anche della shell un modulo ma era un vero macello… del resto è evidente che la shell è un requisito. La struttura dei progetti nella solution è qualcosa del tipo:</span><br>  <ul>   <li><em>MyApplication</em> (WPF App Project);</li>    <li><em>MyApplication.System</em> (Class Library):</li>    <ul>     <li>definisce i contratti dei servizi esposti al nostro ecosistema;</li>   </ul>    <li><em>MyApplication.System.Windows </em>(Class Library):</li>    <ul>     <li>definisce i servizi esposti all’ecosistema dipendenti da WPF, questo progetto può essere “mergiato” con il precedente con lo scotto che tutti i progetti a questo punto dipenderanno dall’infrastruttura di WPF. “Filosoficamente” è sbagliato;</li>   </ul>    <li><em>MyApplication.Runtime</em> (Class Library):</li>    <ul>     <li>implementa i contratti di MyApplication.System e MyApplication.System.Windows, volendo qui potremmo avere la stessa separazione in Runtime e Runtime.Windows ma non è detto che ci serva/abbia senso;</li>   </ul>    <li><em>MyApplication.Boot</em> (Class Library)</li>    <ul>     <li>è il bootstrapper;</li>      <li>questo signore conosce il framework di IoC, i contratti e le implementazioni concrete;</li>   </ul>    <li><em>Toolkit</em> (Class Library)</li>    <ul>     <li>contiene contratti e implementazioni astratte delle classi di base per facilitare lo sviluppo;</li>   </ul> </ul>  <span>Se volete dare un okkio alla struttura trovate il tutto qui: <a href="http://downloads.topics.it/composite_ui_samples/CompositeUI_v1.zip" target="_blank">CompositeUI_v1.zip</a>.</span><br>  <span>Per ora non fa proprio nulla se non:</span><br>  <ul>   <li>Configurare il container;</li>    <li>Avviare l’applicazione e la Shell;</li> </ul>  <span>Se consideriamo per fare 2 stupidate ci sono 6 progetti nella solution direi che cominciamo bene. Per farlo funzionare assicuratevi che:</span><br>  <ol>   <li>Compili… :-D;</li>    <li>Il Project Build Order sia quello giusto:</li>    <ol>     <li>destro sulla Solution –> Project Dependencies –> nella combo selezionate il progetto MyApplication e verificate che tutti gli altri progetti siano spuntati;</li>   </ol> </ol>  <span>Se siete fortunati e il file .suo è arrivato a voi intatto dovreste anche avere un po’ di breakpoint già inseriti, un bel F5 e studiate cosa succede. Fin qui non è nulla di difficile anzi… sintetizzando quello che avviene è:</span><br>  <ol>   <li>Parte l’applicazione WPF;</li>    <li>Nell’OnStart:</li>    <ol>     <li>recuperiamo, dietro le quinte via reflection, una reference all’IAppicationBootstrapper concreto;</li>      <li>invochiamo il metodo Boot();</li>   </ol>    <li>Il Bootstrapper:</li>    <ol>     <li>per prima cosa istanzia e configura il container (Castle Windsor nell’esempio);</li>      <li>chiede al container di risolvere il ViewModel della Shell;</li>      <li>avvia la Shell;</li>   </ol> </ol>  <span>Prossimo passo sarà quello di definire un sistema per “descrivere” al motore di boot quali sono i moduli installati.</span><br>  <span>Stay tuned… e non sparate sul pianista, o meglio magari non sparate troppo in basso :-P</span><br>  <span>.m</span><br>  <span>Allegati: <a href="http://downloads.topics.it/composite_ui_samples/CompositeUI_v1.zip" target="_blank">CompositeUI_v1.zip</a>.</span><br>  

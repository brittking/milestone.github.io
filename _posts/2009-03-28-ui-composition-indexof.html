---
layout: post
title: 'UI Composition :: IndexOf()'
date: '2009-03-28T17:00:00.000+01:00'
author: Mauro Servienti
tags:
- Software Mason
- Architecture
- UI Composition
modified_time: '2012-01-31T14:03:29.724+01:00'
thumbnail: https://lh6.googleusercontent.com/-3PbqDariXcY/Tyfmlx7LIHI/AAAAAAAAAVY/6V2bKEdn6AA/s72-c/image_thumb_1.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-7528363464176642512
blogger_orig_url: http://milestone.topics.it/2009/03/ui-composition-indexof.html
---

<span><a href="http://blogs.ugidotnet.org/topics/archive/2009/03/27/ui-composition-thread.start.aspx" target="_blank">Continuiamo</a>…</span><br>  <span>Siamo ancora ad un livello introduttivo, cerchiamo di capire quali sono le problematiche tecniche che dovremo affrontare e perchè.</span><br>  <span><strong>Dogma</strong>: Diamoci delle regole e rispettiamole.</span><br>  <blockquote>   <span>Nello sviluppo di applicazioni complesse, e comunque in generale nell’applicazione di un pattern, non abbiamo nessun supporto dall’ambiente di sviluppo, questo significa, ad esempio, che il compilatore (san csc.exe :-D) non ci aiuta in nessun modo segnalandoci che stiamo facendo una certa cosa nel modo sbagliato. Abbiamo quindi bisogno di capire quali sono i problemi, trovare una soluzione che ci permetta di rispettare i requisiti e poi non deviare dal seminato, perchè è facile farsi prendere dalla fretta e “appiccicare” una soluzione che poi inevitabilmente alla lunga ci si ritorcerà contro. Soprattuto ora in cui l’obiettivo è costruire un toolkit che sia riutilizzabile.</span><br> </blockquote>  <span><strong>UI Design</strong></span><br>  <span>La prima cosa che facciamo è disegnare un concept della UI che vogliamo realizzare, è irrilevante che funzioni o meno ci basta avere qualcosa da far vedere al cliente e qualcosa da analizzare per capire quali possono essere le problematiche. In questo senso wpf/xaml unito a Expression Blend sono una vera manna.</span><br>  <span>Il nostro obiettivo è arrivare qui:</span><br>  <span><a href="https://lh6.googleusercontent.com/-IqStUDN_zNw/TyfmmIVWidI/AAAAAAAAAVc/AQD4rNngzr8/image_4.png" rel="lightbox"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="https://lh6.googleusercontent.com/-3PbqDariXcY/Tyfmlx7LIHI/AAAAAAAAAVY/6V2bKEdn6AA/image_thumb_1.png" width="244" height="174"></a> </span><br>  <span>Nell’immagine ho evidenziato:</span><br>  <ul>   <li>in viola le aere (Region) che la Shell mette a disposizione per fare UI Injection; </li>    <li>in rosso la Region che il dettaglio dell’elemento selezionato mette a disposzione per la UI Injection; </li> </ul>  <span>Quello che vediamo nell’immagine è così strutturato:</span><br>  <ul>   <li>Ogni Ribbon Tab viene iniettata, ma non è una regola, da un modulo in una RibbonRegion esposta dalla Shell. Ogni Ribbbon Tab, come del resto ogni elemento della UI è formato <u>sempre</u> da una coppia View/ViewModel. Nell’immagine vediamo:       <ul>       <li>SubjectsManagerView; </li>        <li>SubjectsManagerViewModel; </li>     </ul>   </li>    <li>a seguito di una ricerca vengono visualizzati i risultati in una DocumentWindow iniettata in una DocumentsRegion offerta dalla Shell; </li>    <li>Se eseguite una seconda ricerca, senza selezionare la check-box, la DocumentWindow viene riutilizata per visualizzare i risultati; </li> </ul>  <span>Quello che vediamo graficamente può essere schematizzato così:</span><br>  <span><a href="https://lh3.googleusercontent.com/-cRIhQRnUt8A/TyfmnZYGUXI/AAAAAAAAAVs/av_wQHt6di4/image_6.png" rel="lightbox"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="https://lh4.googleusercontent.com/-GbNSnoSzM7Y/Tyfmm9J9U1I/AAAAAAAAAVk/cXwnyZGYWJw/image_thumb_2.png" width="244" height="171"></a> </span><br>  <span>E’ evidente che la schematizzazione ci fa capire che le cose dietro le quinte sono un filino complesse, e M-V-VM non ci aiuta certo nella gestione, nonostante da un lato semplifichi notevolmente dall’altro introduce un ulteriore livello di complessità.</span><br>  <span>Inoltre è importante notare che l’esempio schematizzato è di quelli semplici perchè il nesting delle region, e della conseguente injection di elementi, potrebbe andare avanti all’infinito e nell’applicazione che stiamo realizzando è effettivamente un filino più complesso di questo concept.</span><br>  <span>Nello schema ho anche evidenziato quali sono le <u>uniche</u> zone di collegamento note tra i vari attori: solo ed esclusivamente il data binding tra View e ViewModel, nulla di più.</span><br>  <span>Per come funziona il modello è evidente che non è possibile avere una reference a SubjectsManagerViewModel ad esempio da SubjectsSearchResultsViewModel, da questo se ne deduce che non ha senso esporre un evento (eg. SearchRequest) da SubjectsManagerViewModel e agganciarvi un handler da SubjectsSearchResultsViewModel ad esempio per eseguire la ricerca.</span><br>  <span>Questo ci pone di fronte al primo problema.</span><br>  <span><strong>La comunicazione</strong></span><br>  <span>l'esempio che abbiamo appena sfiorato ci impone di trovare un sistema per far comunicare le varie parti del nostro ecosistema in maniera disaccoppiata, senza usare eventi.</span><br>  <span>La scelta che ho fatto è stata quella di optare per un sistema di messaggistica interno all’applicazione basato sul modello publisher/subscriber. Ne ho già <a href="http://blogs.ugidotnet.org/topics/archive/2009/02/08/imessagebroker.aspx" target="_blank">parlato su questi schermi</a> quindi direi che questo paragrafo lo possiamo dare per assodato.</span><br>  <span>Entrambi i 2 blasonati toolkit che ho preso in considerazione affrontano e risolvono il prolema in maniera molto simile.</span><br>  <span>Quello che succede quindi nella nostra UI è che alla pressione del pulsante cerca viene inviato un messaggio che contiene la richiesta di ricerca, questo messaggio viene “<em>gestito da un handler</em>”, ne parleremo, che altro non fa che recuperarare una reference al ViewModel che visualizza i risultati, passargli le informazioni sulla ricerca inserite dall’utente e invocare l’esecuzione della ricerca.</span><br>  <span>Per fare tutto ciò e non impazzire la soluzione ideale è utilizzare un framework di Inversion of Control…</span><br>  <span><strong>Inversion of Control e Dependency Injection</strong></span><br>  <span>Castle Windsor, ma il discorso vale anche per gli altri (Prism di default usa Unity ma è possibile rimpiazzarlo), ci permette di semplificare, centralizzare e configurare la gestione delle dipendenze tra i vari componenti all’interno di ogni modulo e tra i moduli stessi volendo.</span><br>  <span>L’introduzione di questo modello ci porta a poter realizzare qualcosa di decisamente interessante, questo snippet di codice ci pone uno scenario molto interessante:</span><br>  <span>namespace <strong>ModuleA</strong>     <br>{     <br>   class DoSomethingInterestingViewModel     <br>   {     <br>      void Method()     <br>      {     <br>         var env = this.GetService<IEnvironmentService>();     <br>         if( env.IsModuleRunning<<strong>ModuleB</strong>.IModule>() )     <br>         {     <br>            var svc = this.GetService<<strong>ModuleB</strong>.IOtherServiceInOtherModule>();     <br>            svc.BlaBla();     <br>         }     <br>      }     <br>   }     <br>}</span><br>  <span>da un ipotetico modulo A possiamo accedere ad informazioni gestite da un ipotetico modulo B, la cosa è decisamente fattibile, funziona e vi permette scenari molto ma molto interessanti… ma…</span><br>  <span><strong>Il processo di Boot</strong></span><br>  <span>Se abbiamo bisogno di soddisfare lo scenario appena visto ci troviamo di fronte alla magagna che il container di IoC deve essere uno ed uno solo e in fase di boot dell’applicazione ogni modulo deve avere la possibilità di configurare il sistema per far si che possa rispondere alle proprie esigenze e eventualmente a quelli di altri.</span><br>  <span>Questo ci porta ad un processo di boot fatto da una serie di stage:</span><br>  <ul>   <li><u>Discovery</u>: durante la fase di discovery vengono cercati tutti i moduli installati e vengono caricati dei “proxy” (ModuleDescriptor) che descirvono i moduli; </li>    <li><u>Initialize</u>: tutti i moduli che dovranno effettivamente essere caricati/utilizzati passano da una fase di intialize in cui hanno la possibilità di accedere alla configurazione del container e iniettare la propria parte di configurazione; </li>    <li><u>Startup</u>: i moduli inizializzati vengono a tutti gli effetti avviati dando inizio alle danze; </li> </ul>  <span><strong>I Moduli</strong></span><br>  <span>Un modulo è fatto come minimo da 3 parti:</span><br>  <ol>   <li><u>ModuleDescriptor</u>: rappresenta un modulo, fornisce informazioni descrittive ed è in grado di “trasformarsi” in un ModuleBootstrapper; Lo scopo di un ModuleDescriptor è quello di avere informazioni riguardo ad un modulo senza necessariamente avere un riferimento a quel modulo e quindi senza dover caricare in memoria nulla che riguardi quel modulo; </li>    <li>Un ModuleDescriptor all’occorrenza può diventare un <u>ModuleBootstrapper</u> che è quel componente, a questo punto specializzato per il modulo che stiamo caricando, in grado di inizializzare la configurazione del modulo stesso. </li>    <li>Il processo di bootstrap porta alla creazione di un’istanza di un <u>IModule</u> che è a tutti gli effetti il nostro modulo, un IModule ha un solo metodo Run() che verrà invocato al momento giusto dall’engine di boot. </li> </ol>  <span>Quello che succede durante il processo di avvio ad esempio è una cosa del tipo:</span><br>  <ol>   <li>Il processo di boot viene avviato; </li>    <li>viene eseguita la configurazione del container da parte della Shell; </li>    <li>viene fatto il discovery dei moduli:      <ol>       <li>vengono caricati i bootstrapper; </li>        <li>viene data la possibilità ai bootstrapper di partecipare al processo di configurazione; </li>        <li>vengono avviati i moduli; </li>     </ol>   </li>    <li>la Shell si avvia definitivamente e:      <ol>       <li>registra, vedremo come, le region che saranno disponibili ai moduli; </li>        <li>notifica, via message broker, al mondo che si sta avviando; </li>     </ol>   </li>    <li>Ogni modulo ha l’opportunità di reagire (message Subscription) all’avvio della Shell:      <ol>       <li>può recuperare un riferimento alle region “pubblicate” dalla Shell; </li>        <li>può iniettare contenuti, ad esempio nel RibbonTab, nella Shell; </li>     </ol>   </li> </ol>  <span>Alla pressione del pulsante “Cerca” succede una cosa molto simile, quindi per ora passo.</span><br>  <span><strong>Dynamic Region(s)</strong></span><br>  <span>Ma… maledetti ma ;-)… una cosa che deve essere possibile fare è questa:</span><br>  <span><a href="https://lh5.googleusercontent.com/-9TyxoLHCQI0/TyfmoEoForI/AAAAAAAAAV4/3vBgMiIj5IQ/image_8.png" rel="lightbox"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="https://lh6.googleusercontent.com/-tvXj8KArPwA/Tyfmn3sH4rI/AAAAAAAAAVw/ubO58gU4dzI/image_thumb_3.png" width="244" height="219"></a> </span><br>  <span>eseguire cioè 2 ricerche in 2 finestre distinte (qui le ho affiancate sfruttando una fantastica suite di controlli di un collega MVP: <a href="http://www.divelements.co.uk/net/controls/" target="_blank">Tim Dawson</a>). Questo porta ad un altro piccolo problema: le Region non possono essere definite a priori (come ad esempio fa PRISM v1) in maniera statica perchè se definissi una generica Region “SelectedSubjectDetails” non saprei come fare a gestire le 2 istanze di cui sopra.</span><br>  <span>Inizialmente ero quindi partito definendo il concetto di region Statiche, che esistono (punto) e possono essere recuperate per nome, e di region dinamiche di cui poteva essere fatto il discovery a runtime. Alla fine era troppo complesso da gestire e anche da usare in realtà se ci pensiamo possiamo asserire che tutte le region sono dinamiche solo che alcune hanno la caratteristicha di esistere per tutto il ciclo di vita dell’applicazione proprio come se fossero dei singleton, non lo sono ma il concetto calza a pennello.</span><br>  <span>Il tutto adesso è gestito da una triade:</span><br>  <ul>   <li><u>RegionService</u>: è il motore che consente la registrazione delle Region e la gestione dei RegionManager, c’è un solo RegionService per tutti; </li>    <li><u>RegionManager</u>: è il componente che si occupa di gesire un insieme di region, i RegionManager possono essere creati, distrutti e manipolati, sono l’entry point per avere accesso alle region. Nel mio modello se una View definisce delle region esisterà un RegionManager per quella View; non è possibile, e non ne vedo la necessità, avere più RegionManager collegati ad una singola View; </li>    <li><u>Region</u>: è la definizione astratta di un’area in cui è possibile iniettare contenuti, ogni Region ha le sue regole ed è la Region stessa che decide come visualizzare e gestire i contenuti che vengono iniettati; alcuni esempi:       <ul>       <li>Region<Ribbon>: è un tipo di region pensato per ospitare RibbonTab(s); </li>        <li>Region<DocumentContainer>: un tipo di Region pensato per ospitare DocumentWindow(s); </li>        <li>Region<ContentPresenter>: un tipo di region pensato per ospitare un singolo contentuo figlio; </li>        <li>Region<NonC’èLimiteAllaFantasia>…; </li>     </ul>   </li> </ul>  <span>Un RegionManager è naturalmente in grado di gestire Region tra loro eterogenee.</span><br>  <span><strong>Navigation System</strong></span><br>  <span>Ci troviamo infine nella terra di nessuno, sia Caliburn che Prism fanno acqua in questo senso, ci rendiamo cioè conto che la nostra applicazione non è fatta da una singola finestra… sarebbe bello, ma su quale pianeta ;-)</span><br>  <span>Quello che vogliamo poter fare è, ad esempio:</span><br>  <ul>   <li>fare doppio click su un risultato di una ricerca e aprire una Window che ci visualizzi l’elemento nella sua interezza e, ad esempio, in lettura/scrittura; </li>    <li>nel momento in cui facciamo doppio click su un elemento che stiamo già visualizzando in un’altra Window semplicemente portare quella Window in primo piano; </li> </ul>  <span>Tutto questo viene delegato ad un NavigationService che è quel componente che è in grado di orchestrare i rapporti tra le varie Window, non sa nulla delle Window stesse ma le conosce quel tanto che basta per poterci dialogare.</span><br>  <span><strong>And now…</strong></span><br>  <span>Anche stavolta di carne al fuoco ne abbiamo messa parecchia, nelle prossime puntate cercheremo di affrontare ogni singolo punto nel dettaglio che più dettaglio non si può :-). Ho anche creato una <a href="http://blogs.ugidotnet.org/topics/category/3551.aspx" target="_blank">categoria</a> ad hoc.</span><br>  <span>Spero che il tempo tiranno mi permetta di continuare questa serie senza troppe pause di riflessione ;-)</span><br>  <span>.m</span><br>  
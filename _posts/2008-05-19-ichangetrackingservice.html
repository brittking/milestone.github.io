---
layout: post
title: IChangeTrackingService
date: '2008-05-19T20:24:00.000+02:00'
author: Mauro Servienti
tags:
- Why not...
modified_time: '2012-01-28T11:31:35.833+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-510977580112069157
blogger_orig_url: http://milestone.topics.it/2008/05/ichangetrackingservice.html
permalink: /2008/05/ichangetrackingservice.html
---

<span>...un po' di storia: tanto tempo fa in una galassia lontana lontana... comiciai a scrivere applicazioni gestionali Windows Forms... mano a mano che il mondo evolveva mi resi conto che, forse addirittura più nel nostro lavoro che in altri, l'abito fa eccome il monaco. Con questo intendo dire che spessissimo il giudizio ultimo sul nostro lavoro lo danno "<em>non tecnici</em>" che si limitano a valutare le funzionalità di alto livello che il nostro prodotto offre. Da questo ritengo abbastanza facile dedurre che l'interfaccia utente, e qui credo di non dire nulla di nuovo, ricopra un ruolo fondamentale perchè è il con la UI che il nostro <em>giudice</em> ha il primo approccio.</span><br>  <span>Fatta questa doverosa premessa veniamo a quello che successe: un bel giorno una delle ragazze che lavoravano in contabilità da un cliente mi chiese (parlando dell'applicazione che avevo sviluppato e che lei utilizzava): "ma non ci sarebbe la possibilità di avere l'avanti e indiero come in Word?" la pima reazione fu un grosso punto di domanda... avanti e indietro?? ma che è... indagando poi scoprii che la ragazza si riferiva alle funzionalità di Undo/Redo offerte da Office.</span><br>  <span>La cosa mi incuriosì non poco e comincia a studiare il "meccanismo" (aka "<em>pattern</em>") che gestiva la cosa e la prima, ed unica veramente problematica, considerazione a cui giunsi era che per Word la cosa era "relativamente semplice" perchè Word sapeva molto bene cosa stava gestendo, e cioè il documento, mentre la mia velleità era quella di realizzare un motore che fosse in grado di maneggiare un generico grafo di oggetti.</span><br>  <span>La prima implementazione di tutto vide la luce qualche anno fa, e la ragazza della contabilità fu felice, realizzata con il fx 1.0. Era qualcosa di decisamente embrionale erano le stesse entities che tenevano traccia delle variazioni (o meglio solo della prima variazione) che subivano:</span><br>  <span>public string Company    <br>{     <br>    get { return this._company; }     <br>    set     <br>    {     <br>        if(base.ObjectCache["Company"] == null)     <br>            base.ObjectCache["Company"] = this._company;     <br>        this._company = value;     <br>    }     <br>}</span><br>  <span>Avevo semplicemente un dictionary dove il nome della proprietà era la chiave e il value il valore, veniva cachata solo ed esclusivamente la prima modifica e nulla di più. L'entity esponeva poi metodi e proprietà per <em>giocare</em> con la cache:</span><br>  <ul>   <li>AcceptChanges(); </li>    <li>AcceptChanges( Boolean recursive ); </li>    <li>RejectChanges(); </li>    <li>RejectChanges( Boolean recursive ); </li>    <li>GetHasChanges(); </li>    <li>GetHasChanges( Boolean recursive ); </li> </ul>  <span>I metodi con il parametro boolean permettevano di capire se l'intero grafo avesse subito modifiche o se le modifiche erano limitate al solo oggetto che si stava indagando. Il tutto naturalmente funzionava anche per le collection anche se la manutenibilità del codice era decisamente lontana dal potersi considerare accettabile.</span><br>  <span>Adesso mi vengono i brividi ;-) ma 6 e più anni fa faceva la sua porca figura... il tempo e le necessità mi hanno fatto evolvere verso qualcosa di decisamente più funzionale, e finalmente oggi, anche molto più bello dal punto di vista del design.</span><br>  <span>Partiamo dai requisiti che possono essere sintetizzati in un una parola: "<a href="http://www.dofactory.com/Patterns/PatternMemento.aspx" target="_blank">Memento</a>" (che non è solo un <a href="http://www.hyperreview.com/Memento.htm" target="_blank">bellissimo film</a>).</span><br>  <span>I problemi: </span><br>  <ul>   <li>gestiamo un grafo non necessariamente noto a priori; </li>    <li>gestiamo un grafo che può essere internamente gestito con il "lazy loading" e non vogliamo che il modello <a href="http://blogs.ugidotnet.org/topics/archive/2008/05/16/lazyloading-collection-e-il-virtualmode.aspx" target="_blank">venga caricato tutto</a> solo perchè dobbiano gestirne le variazioni di stato; </li>    <li>vogliamo poter distinguere <em>n</em> <em>track line</em> per gestire in contemporanea grafi differenti senza che le modifiche vengano mischiate: faccio prima a fare un esempio che ha spiegare: se in VS fate modifiche su file diversi tutte le modifiche vengono tracciate ma, anche se le fate un po' qua e un po' la in maniera casuale, quando fate Undo viene fatta la cosa giusta sul file giusto ma soprattutto se fate Undo su un documento n volte vengono ripristinate solo le modifiche a quello specifico file anche se durante l'editing le avete mischiate, in quanto ad ordine, a quelle di un altro file. </li> </ul>  <span>Nel tempo sono passato attraverso varie implementazioni di un motore di caching dello stato di una entity, ho scritto anche un <a href="http://msdn.microsoft.com/it-it/library/cc185102.aspx" target="_blank">articolo</a> che spiega (stringendo molto) quello che ho adesso in produzione, e seppur tutte funzionanti avevano un grosso difetto: delegavano alla stessa entity l'onere di fare cache del suo stato, non che ritenga la cosa così grave anche perchè il motore, che è tutt'ora usato, è decisamente smart e copre circa il 90% delle casistiche che ho incontrato sino a questo momento.</span><br>  <span>Il framework 2.0 introduce 2 nuove interfacce IChangeTracking e IRevertibleChangeTracking, peraltro inutilizzate dal fx stesso, che servono per gestire proprio un motore di caching. La cosa fuorviante in questo caso è MSDN stessa che, per IChangeTracking ad esempio, recita:</span><br>  <span>"<em>Defines the mechanism for querying the object for changes and resetting of the changed status.</em>"</span><br>  <span>Lasciando supporre che sia la entity a dover fornire/gestire queste informazioni.</span><br>  <span>In questo periodo ci si stava ponendo però un potenziale scenario in cui avremmo sprecato un sacco di risorse (cicli CPU, non ore/uomo) inultilmente proprio perchè la gestione dello stato era delegata alla stessa entity. Non mi dilungo sui motivi, sto già scrivendo troppo oggi... ;-) avremo l'occasione per parlarne presto.... e chi ha orecchie per intendere intenda.</span><br>  <span>Dato questo incipit in questo week-end <em>diluviante</em> mi sono messo d'impegno e ho cercato di capire cosa potevo fare, la prima cosa è stato come sempre guardare il resto del mondo: in molti usano l'interfaccia INotifyPropertyChanged, o meccanismi simili <em>proxando</em> l'interfaccia pubblica di una entity, ma devo dire che a me piace veramente poco:</span><br>  <ul>   <li>obbliga/permette di gestire le sole proprietà pubbliche; </li>    <li>il valore <em>cachato</em> è necessariamente quello esposto mentre potrebbe essere necessario customizzare questo processo; </li>    <li>in fase di "rollback/undo" è decisamente complesso capire, dall'interno della entity, che il set di una property è dovuto al rollback e non ad altro e questo è necessario per evitare di triggerare ancora il motore di caching portando a ricorsione; </li>    <li>va <em>ancora ancora benino</em> finchè stiamo tentando di tracciare le modifche ad una singola entity molto semplice, la classica Person, ma se pensiamo ad un grafo complesso, ad esempio un Customer con Orders e relativi OrderItems e Products, Addresses ed altro l'interfaccia INotifyPropertyChanged è decisamente inadeguata; </li> </ul>  <span>La soluzione a cui sono giunto è ancora un po' grezza ma perfettamente funzionante e decisamente più lineare dal punto di vista del design. Come al solito mi sono ispirato a quello che gia c'è, e di cui <a href="http://msdn.microsoft.com/it-it/library/cc185103.aspx" target="_blank">ho anche scritto</a>, in questo caso System.Transactions.TransactionScope:</span><br>  <span>using( TransactionScope ts = new TransactionScope() )    <br>{     <br>    //Do something     <br>    ts.Complete();     <br>}     <br>    <br>qualsiasi operazione eseguiamo o oggetto istanziamo, all'interno del blocco using, è in grado di eseguire l'enlistment nella transazione in maniera automatica senza che ci sia passaggio di alcunchè tra il blocco di codice di esempio e gli oggetti che vengono usati, a qualsiasi livello si trovino. Altra cosa interessante è che se la transazione non c'è, perchè ad esempio non abbiamo creato un oggetto TransactionScope, il codice funziona perfettamente... e non è che sia poi così scontato ;-)</span><br>  <span>Quello a cui sono giunto è questo:</span><br>  <span>IChangeTrackingServiceProvider provider = ChangeTrackingServiceProvider.GetCurrent();    <br>provider.CreateTrackingService(); </span><br>  <span>IList<Person> list = new EntityCollection<Person>();    <br>Person p = new Person();     <br>p.FirstName = "Mauro";     <br>p.LastName = "Servienti"; </span><br>  <span>list.Add( p ); </span><br>  <span>IChangeTrackingService svc = provider.GetTrackingService();    <br>if( svc.IsChanged )     <br>{     <br>    svc.RejectChanges();     <br>}</span><br>  <span>Perchè il tutto funzioni non è necessario implementare nessuna interfaccia sulle entity che si stanno realizzando è però necessario sacrivere un minimo di codice per "collegare" i 2 mondi. Nell'esempio per la collection viene utilizzata un EntityCollection<T> che è una mia classe, che implementa IList<T> (e non solo), da cui è possibile derivare e che sgravia l'utilizzatore/inheritor da tutto il plumbing code necessario per la gestione del tracking delle modifiche all'interno di una lista (cosa non proprio banale). Mentre la classe Person deriva da una mia classe Entity e si limita ad 1 chiamata ad un metodo della classe base, nel caso in cui ci si volesse totalmente sganciare dalla mia implementazione è sempre possibile farlo, anche in maniera parziale, perchè tutto è implementato da classi concrete che derivano da classi astratte (che offrono una implementazione di base) ma che vengono sempre esposte sotto forma di interfacce: è quindi possibile, in maniera decisamente semplice, pluggare un proprio modello e personalizzare pesantemente il tutto.</span><br>  <span>Ecco quello che succede in esecuzione:</span><br>  <span><a href="http://blogs.ugidotnet.org/images/blogs_ugidotnet_org/topics/WindowsLiveWriter/IChangeTrackingService_EBAB/image_2.png"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="320" alt="image" src="http://blogs.ugidotnet.org/images/blogs_ugidotnet_org/topics/WindowsLiveWriter/IChangeTrackingService_EBAB/image_thumb.png" width="644" border="0"></a> </span><br>  <span>Non uso un blocco using, anche se IChangeTrackingService implementa IDisposable, perchè il ciclo di vita della entity, e quindi la sua gestione dello stato tendono ad andare oltre lo scope del singolo snippet di codice. Ogni metodo esposto dall'interfaccia IChangeTrackingServiceProvider ha svariati overload che permettono di raffinare/personalizzare il comportamento del motore di caching. Una volta recuparata uan reference all'IChangeTrackingService corrente oltre ad accettare o rifiutare (AcceptChanges() o RejectChanges()) è possibile eseguire un "<em>Undo</em>" progressivo delle modifiche apportate, banalmente una cosa del tipo:</span><br>  <span>while( svc.IsChanged )    <br>{     <br>    svc.Undo();     <br>}</span><br>  <span>E' infine possibile chiedere all'IChangeTrackingService di restituirci un IChangeSet che è l'insieme delle modifiche che sta tracciando.</span><br>  <span>IChangeSet cSet = svc.GetChangeSet();</span><br>  <span>Il metodo GetChangeSet() ha, per ora, un overload che accetta un IChangeSetFilter che è un oggetto che permette di "filtrare" dall'esterno quali modifiche debbano essere incluse nel changeset che si sta costruendo. Questa possibilità è ancora molto grezza ed è legata ad una possibile collaborazione con qualcosa che implementi il pattern "Unit Of Work" (<a href="http://download.manageddesigns.it/nsk.aspx" target="_blank">vedasi NSK per i dettagli</a>) al fine di poter scrivere una cosa del tipo:</span><br>  <span>using( IUnitOfWork uow = <em>IServiceContainer</em>.GetService<IUnitOfWork>() )     <br>{     <br>    uow.Append( cSet );     <br>    uow.Commit();     <br>    cSet.AcceptChanges();     <br>} </span><br>  <span>Anche se già funzionante la sua implementazione interna lascia molto a desiderare.    <br>Lascio ad un futuro post i dettagli implementativi del tutto... per oggi ho già intasato troppo il muro di UGI.</span><br>  <span>.m</span><br>

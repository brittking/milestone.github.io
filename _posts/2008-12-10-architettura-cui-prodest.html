---
layout: post
title: 'Architettura: cui prodest?'
date: '2008-12-10T13:04:00.000+01:00'
author: Mauro Servienti
tags:
- Software Mason
modified_time: '2012-01-30T12:51:16.068+01:00'
thumbnail: https://lh6.googleusercontent.com/-pOGKuP-uDpM/TyaEIeuylkI/AAAAAAAAAPI/Gnz_csNs6u8/s72-c/image_thumb.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-2328781871325261980
blogger_orig_url: http://milestone.topics.it/2008/12/architettura-cui-prodest.html
---

<span>Prendo spunto da un <a href="http://blogs.ugidotnet.org/duz/archive/2008/12/09/linq2dal.aspx" target="_blank">post</a> di <a href="http://blogs.ugidotnet.org/duz" target="_blank">Mario</a> per allargare la discussione e dire la mia in un contesto più comodo, i commenti purtroppo non sono comodi e non abbiamo più un forum, speriamo che torni presto perchè sarebbe stato il posto ideale.</span><br>  <span><em>Disclaimer</em>: </span><br>  <span>Quando parliamo di architettura ci possiamo mettere su due livelli:</span><br>  <ol>   <li>Architettura fine a se stessa: inteso come la soluzione ideale in un mondo ideale; </li>    <li>Architettura calata nel contesto: la soluzione ideale con tutti i constraint del caso derivanti dal mondo che sto vivendo in quel momento, tipicamente le esigenze del cliente; </li> </ol>  <span>Questo post vuole solo ed esclusivamente fermarsi al punto 1. Ha senso fermarsi al punto 1? si, perchè ad esempio il punto 2 non esisterebbe senza il punto 1 poi potremmo anche scoprire che neanche il punto 2 ha senso perchè non ha senso parlare di architettura… ma non è oggetto di questo post.</span><br>  <span>Partendo dalla notte dei tempi ci hanno insegnato che un modello possibile è sintetizzabile così:</span><br>  <span><a href="https://lh4.googleusercontent.com/-E2rV8Nda8ic/TyaEI37W04I/AAAAAAAAAPM/kWGQDUIDYpg/image_2.png" rel="lightbox"><img title="image" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="168" alt="image" src="https://lh6.googleusercontent.com/-pOGKuP-uDpM/TyaEIeuylkI/AAAAAAAAAPI/Gnz_csNs6u8/image_thumb.png" width="240" border="0"></a> </span><br>  <span>Questo modello si può evolvere ed arricchire fino ad arrivare a qualcosa di simile al concetto di <a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/" target="_blank">onion</a>, ma non è questo l’argomento; quel modello alla fine della fiera ci permette di scrivere un qualcosa del tipo:</span><br>  <blockquote>   <span>Person aPerson = myPersonRepository.GetById( “mauro” );</span><br> </blockquote>  <span>Questo probabilmente produce una chiamata verso un db con un comando sql, i dati tronano indietro viene istanziata una Person e i dati vengono “spinti” nell’istanza di Person appena creata.    <br>Quali sono i limiti di questo approccio? è decisamente rigido. A fronte della necessità di “cercare” istanze di Person con criteri diversi bisogna estendere il DAL/BusinessLayer aggiungendo le funzionalità del caso. Ecco che ci si comincia a chiedere se un linguaggio di query ad alto livello non abbia senso in questo contesto e la risposta che ci diamo è quasi certamente si.</span><br>  <span>Possiamo quindi evolvere il nostro modello introducendo qualcosa che ci aiuti, e che nel mondo reale probabilmente ci salva la vita:</span><br>  <span><a href="https://lh3.googleusercontent.com/-3KAORJd0-gw/TyaEJrxOGoI/AAAAAAAAAPY/54Og6im0S3o/image_4.png" rel="lightbox"><img title="image" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="136" alt="image" src="https://lh6.googleusercontent.com/-HM_5j-U0_qk/TyaEJL2fSaI/AAAAAAAAAPQ/XXx0832kY1A/image_thumb_1.png" width="240" border="0"></a> </span><br>  <span>e produrre un codice del tipo:</span><br>  <blockquote>   <span>IDataContext session = //Bla bla…      <br>Person aPerson = session.Get<Person>( “<em>queryDefinition</em>” );</span><br> </blockquote>  <span>l’esempio è triviale, in pseudo codice e potrebbe essere adattato a molti O/RM (o simili…) ma ancora una volta non è questo l’argomento, come non lo è il concetto di transazione di business ne tanto meno quello di data context.    <br>Quello che invece mi preme far notare è che nel nostro modello abbiamo introdotto qualcosa che abbiamo definito <em>infrastruttura</em> e che alla fine della fiera è trasversale anch’essa all’applicazione introducendo una dipendenza.     <br><em>n.d.r.</em> Non è detto che questo debba essere visto come un problema nel mondo reale, anzi.</span><br>  <span>Se cominciamo a ragionare ci rendiamo conto che quella dipendenza, nel mondo reale è decisamente difficile da rimuovere, l’esempio lampante è <a href="http://www.codeplex.com/NSK" target="_blank">NSK</a>, in <a href="http://www.codeplex.com/NSK" target="_blank">NSK</a> <a href="http://blogs.ugidotnet.org/pape" target="_blank">Andrea</a>, non è una critica ma una semplice constatazione, espone dal DataContext un metodo GetByCriteria( Query q ) che ha la velleità di astrarre il concetto di query ma se andiamo a guardare l’implementazione o pensiamo ad una possibile implementazione ci rendiamo subito conto che l’obiettivo è decisamente difficile da raggiungere, l’espressività del linguaggio T-SQL, ad esempio, è decisamenta alta e modellare un dominio che lo rappresenti è decisamente difficile.</span><br>  <span>Quello a cui giungiamo quindi è che la nostra creatura consolida la sua dipendenza dall’infrastruttura, e ripeto non è detto che sia un male.    <br>Ci potremmo però trovare in una spiacevole situazione, esperienza proprio di questi giorni:</span><br>  <blockquote>   <span>La topologia di rete dei client che usano la nostra applicazione cambia/evolve, rendendo necessario uno switch da multi-layer a multi-tier perchè alcuni client adesso sono remoti, di mezzo c’è un “malefico” firewall e da li ci passa solo <em>https443</em>.</span><br> </blockquote>  <span><a href="https://lh6.googleusercontent.com/-WuDocRE_sa8/TyaELB9r5uI/AAAAAAAAAPo/PWzNdTQlpko/image_6.png" rel="lightbox"><img title="image" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="132" alt="image" src="https://lh6.googleusercontent.com/-licMLa5Vk14/TyaEKXxyOdI/AAAAAAAAAPk/paXvaiGsTYY/image_thumb_2.png" width="240" border="0"></a> </span><br>  <span>L’infrastruttura smette di funzionare, semplicemente perchè non è pensata per funzionare in quello scenario, ne consegue che l’applicazione smette di funzionare perchè dipende dall’infrastruttura, quello cha abbiamo adesso è un nuovo modello concettuale:</span><br>  <span><a href="https://lh4.googleusercontent.com/-4O1zyipvb_M/TyaEMiZLhMI/AAAAAAAAAP4/f1lcOCvqCcs/image_8.png" rel="lightbox"><img title="image" style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="231" alt="image" src="https://lh4.googleusercontent.com/-N1TsmQYJTqY/TyaELuKXLPI/AAAAAAAAAP0/e1mS2oJn2QQ/image_thumb_3.png" width="240" border="0"></a> </span><br>  <span>in cui purtroppo non possiamo più produrre del codice come quello che abbiamo visto in precedenza se non astraendo il concetto di query, di data context, di transazione di business etc etc.</span><br>  <span>E’ possibile farlo? <u>certo che è possibile</u>;     <br>Come? molto semplice Expression Tree;</span><br>  <span>Sarebbe molto bello poter scrivere una qualcosa del tipo:</span><br>  <blockquote>   <span>IServiceContainer sc = ServiceContainer.GetContainer();      <br>using( IDataContext dc = sc.GetService<IDataContext>() )       <br>{       <br>    var query = dc.Persons.Where( p => p.FirstName == “Mauro” );       <br>    IEntityCollection<IPerson> list = query.ToEntityCollection( dc );       <br>    //Operate on list…       <br>    dc.Commit();       <br>}</span><br> </blockquote>  <span>E’ fattibile? certo che si! quello snippet compila e funziona pure… producendo questo sql:</span><br>  <blockquote>   <span>select [_t0].[id], [_t0].[firstName], [_t0].[lastName] from [Persons] as [_t0] where [_t0].[firstName] = @p1</span><br> </blockquote>  <span>Cosa è costato? un bagno di sangue :-D oltre al <em>dettaglio</em> che quello funziona mentre questo neanche a morire:</span><br>  <blockquote>   <span>var query = from person in dc.Persons where person.FirstName == “Mauro” select person;</span><br> </blockquote>  <span>…nonostante, per lo sviluppatore che l’ha scritto, siano esattamente la stessa cosa… solo per lui purtroppo :-D, ma anche questa è un’altra storia.</span><br>  <span>Quello a cui voglio arrivare è che dal punto di vista della modellazione/astrazione del linguaggio di query adesso (.NET >=3.x) abbiamo quasi tutto, le Lambda Expression sono in questo senso la soluzione ad alto livello, il problema adesso nasce quando si cerca di calare questa bellissima possibilità in un contesto reale e si (ri)scopre che scrivere un query provider per Linq è molto lontano dall’essere un’operazione anche solo pensabile…</span><br>  <span>Ma, alla fine dei conti, serve tutto ciò? non è detto, ripeto dipende dal contesto. Se ci caliamo nella realtà in cui stiamo lavorando potremmo anche arrivare a scoprire, estremizzando nella direzione opposta, che nulla di tutto ciò ha minimamente senso, potremmo arrivare a trovarci di fronte ad applicazioni scritte male, potenzialmente immanutenibili, e intestabili, ma che funzionano e lo fanno bene… e non è fantasia, ho sotto gli occhi due esempi realissimi proprio in questi giorni ;-)</span><br>  <span>.m</span><br>
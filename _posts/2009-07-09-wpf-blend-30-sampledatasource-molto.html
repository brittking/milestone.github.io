---
layout: post
title: Wpf + Blend 3.0 + SampleDataSource = Molto bello!
date: '2009-07-09T22:04:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
modified_time: '2012-02-01T23:40:41.874+01:00'
thumbnail: https://lh3.googleusercontent.com/-DJ5jZK5MeSk/Tym_OozTRDI/AAAAAAAAAg8/18GXeZnHG1U/s72-c/image_thumb.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-8405716124128763567
blogger_orig_url: http://milestone.topics.it/2009/07/wpf-blend-30-sampledatasource-molto.html
permalink: /2009/07/wpf-blend-30-sampledatasource-molto.html
---

<span>Quando prendete confidenza con Wpf scoprite che, tra le tante cose, i template, gli stili e i trigger sono la manna dal cielo. </span><br>  <span>Quando però approcciate lo sviluppo di un’applicazione complessa, che magari vuole anche usare M-V-VM, anche mettendoci tutta la buona volontà scoprite che il design della UI diventa una delle attività più onerose e time consuming nel ciclo di sviluppo. Il motivo è presto detto:</span><br>  <ul>   <li>Se usate come designer Visual Studio (aka Cider) avete l’inghippo che:</li>    <ul>     <li>Definirlo stabile è difficile ;-)</li>      <li>Non c’è mezzo di editare in maniera visuale i template;</li>      <li>Non c’è alcuna possibilità di avere una preview dei dati che a runtime andranno in binding con la UI;</li>      <li>Avete però un ottimo intellisense anche per l’editing dello xaml;</li>   </ul>    <li>Se usate Blend 2 siete invece in una condizione per cui:</li>    <ul>     <li>Non avete supporto dell’intellisense, se non con qualche barbatrucco, per l’editing diretto dello xaml;</li>      <li>Avete però un ottimo designer con la possibilità di editare anche i template;</li>      <li>Avete purtroppo un supporto <em>moltissimo-parzialissimo</em> per il binding dei dati a design-time. La cosa è talmente scomoda, debole e prona ad errori che lasciate perdere pressochè subito… ;-)</li>   </ul> </ul>  <span>L’accoppiata dei 2 non è certo comoda e non allevia le nostre sofferenze… finchè non diamo un’occhiata come si deve a Blend 3.0 (in CTP e scaricabile da <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=A04AA0AE-87BE-4201-A65E-E792859122FC&displaylang=en" target="_blank">qui</a>)</span><br>  <span><strong>Ignorable</strong></span><br>  <span>Prima di approfondire vediamo una cosa che Blend ha/fa da sempre, rispetto a Visual Studio, e che è la base di tutto:</span><br>  <span><a href="https://lh3.googleusercontent.com/-8XVUG1WwyHk/Tym_O25eyRI/AAAAAAAAAhA/P6HVg-Uy664/image_2.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="https://lh3.googleusercontent.com/-DJ5jZK5MeSk/Tym_OozTRDI/AAAAAAAAAg8/18GXeZnHG1U/image_thumb.png" width="404" height="52"></a> </span><br>  <span>Blend, come designer, ha il supporto per un set di attached properties che possono essere piazzate sui controlli e che servono per aggiungere comportamenti a desing-time, come ad esempio il concetto di IsLocked:</span><br>  <span><a href="https://lh4.googleusercontent.com/-vmb-s8DmZXU/Tym_P-IbZnI/AAAAAAAAAhU/ZvoefwaPs7U/image_4.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="https://lh6.googleusercontent.com/-7sGo5ui0zzw/Tym_PW7LCVI/AAAAAAAAAhI/9xMAtjcnQHU/image_thumb_1.png" width="180" height="40"></a> </span><br>  <span>Il bello è che le proprietà vengono bellamente ignorate a run-time permettendo di fatto di avere comportamenti diversi a design-time… interessante! Quindi questo cosa farà?:</span><br>  <span><a href="https://lh6.googleusercontent.com/-3SMUvwDcUbs/Tym_R1HRpiI/AAAAAAAAAhc/xC1KR49zynU/image_6.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="https://lh5.googleusercontent.com/-ND00qAogfHQ/Tym_RfoC4iI/AAAAAAAAAhY/lK1_CB9a6oc/image_thumb_2.png" width="244" height="22"></a> </span><br>  <span><strong>SampleDataSource</strong></span><br>  <blockquote>   <span><em>ndr</em>: Sto ancora facendo esperimenti quindi non ho spinto Blend verso lo spazio profondo ;-), ma per ora promette molto e molto bene.</span><br> </blockquote>  <span>Andiamo per gradi, diciamo che il nostro obiettivo è di realizzare una ListBox “custom” dove la cosa “custom” sono i ListBoxItem e i dati che vanno in pasto alla ListBox provengono da un ViewModel.</span><br>  <span>Gironzolando per Blend troviamo una “nuova” Tool Window: Data, interessante per noi è la possibilità di aggiungere una nuova “Sample Data Source…”, sia apre una dialog che ci permette di definire il nome (la resource key) da assegnare alla data source e se vogliamo persistere al nuova data source a livello di Window o di Application</span><br>  <span><a href="https://lh6.googleusercontent.com/-9rG1FqS5G3M/Tym_TKrI3vI/AAAAAAAAAhw/ug_-Ru65c7o/image_8.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="https://lh3.googleusercontent.com/-wnCl205jkt4/Tym_SR_ojuI/AAAAAAAAAhs/xKJevGRFnTg/image_thumb_3.png" width="244" height="190"></a> </span><br>  <span>Una volta fatto questo possiamo definire un set di proprietà che la nostra sorgente dati espone, a noi fondamentalmente interessano solo i nomi delle proprietà e parzialmente, almeno per ora il tipo. Se vogliamo quindi realizzare un potenziale master-detail lo possiamo fare in questo modo:</span><br>  <span><a href="https://lh5.googleusercontent.com/-OKgvTA8SwtY/Tym_UQnq9OI/AAAAAAAAAiA/Oej5nx5oO_o/image_10.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="https://lh5.googleusercontent.com/-Lip4J8g_4rc/Tym_TtFRTXI/AAAAAAAAAh4/PALao2gJFnE/image_thumb_4.png" width="244" height="185"></a> </span><br>  <span>SelectedPerson non è di certo di tipo Person ma è piuttosto un ComplexType noto a Blend, ma o noi poco importa perchè l’essenziale è che possiamo scrivere, nello xaml, questo:</span><br>  <span><a href="https://lh3.googleusercontent.com/-BHqz6vOgaxk/Tym_VjRn1rI/AAAAAAAAAiQ/iwXKz3Hg3H0/image_12.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: inline; margin-left: 0px; border-top: 0px; margin-right: 0px; border-right: 0px" title="image" border="0" alt="image" align="left" src="https://lh4.googleusercontent.com/-mRNBxThqDLg/Tym_U6TvtgI/AAAAAAAAAiI/96UJ3QtMPjM/image_thumb_5.png" width="384" height="27"></a> </span><br>    <span>Notate il prefisso “d” davanti a DataContext? quel DataContext verrà utilizzato solo a design-time e ignorato a runtime permettendoci di specificare un’altra proprietà DataContext con la binding expression che dovrà essere utilizzata a runtime.</span><br>  <span>A mano fortunatamente dobbiamo fare ben poco, fa tutto il buon Blend; ora possiamo “draggare” una ListBox sulla nostra Window e dalla consueta finestra dei binding selezionare tutto quello che più ci piace:</span><br>  <span><a href="https://lh5.googleusercontent.com/-we-MYr3xZpU/Tym_W12wryI/AAAAAAAAAig/tJuGcRl9XWY/image_14.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="https://lh3.googleusercontent.com/-_hnd9rR6fy4/Tym_WTugVFI/AAAAAAAAAiY/4O5DWDHrlCE/image_thumb_6.png" width="244" height="147"></a> </span><br>  <span>producendo una cosa di questo genere:</span><br>  <span><a href="https://lh3.googleusercontent.com/-z-GbKXgTO6w/Tym_ZNkxqMI/AAAAAAAAAi0/XHVvaiA6-Ns/image_16.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="https://lh5.googleusercontent.com/-uOJUjxtsCmA/Tym_YmZFR7I/AAAAAAAAAis/tuRcx7NJyok/image_thumb_7.png" width="244" height="85"></a> </span><br>  <span>Adesso possiamo metterci a lavorare al nostro template, sempre tutto da designer, e dopo avere realizzato un semplice template vedere <u>direttamente a design-time</u> questo:</span><br>  <span><a href="https://lh6.googleusercontent.com/-SDZrEUTOVAg/Tym_aP_YYQI/AAAAAAAAAjA/fE5J44ukLGY/image_18.png" rel="lightbox"><img style="border-bottom: 0px; border-left: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px" title="image" border="0" alt="image" src="https://lh4.googleusercontent.com/-Uw2Cko0H8Gw/Tym_Zlls5jI/AAAAAAAAAi4/KMUAJ0_mcGY/image_thumb_8.png" width="244" height="146"></a></span><br>  <span>Senza aver scritto un solo pezzetto di xaml a mano. Molto bene, direi che è un gran bel passo in avanti verso qualcosa di concreto e produttivo.</span><br>  <span><strong>Ma non è tutto oro ciò che luccica… purtroppo!</strong></span><br>  <span>…e voi direte:<em> che barba che noia</em> <cit.>, non gli va mai bene nulla :-) nulla di più falso stavolta: quello che abbiamo visto è decisamente potente e flessibile quanto basta per fare il 90% delle cose (se non di più), essendo però “qualcosa” generato da un designer soffre del problema di non poter fare tutto, come ad esempio gestire tipi enumerativi cosa che io personalmente espongo molto volentieri dai miei ViewModel…</span><br>  <span><strong>It’s a kind of magic</strong> <cit.></span><br>  <span>Se andiamo a sbirciare nello xaml scopriamo che non c’è nessuna magia dietro quello che fa Blend, anzi c’è un sacco di tecnologia molto nota :-)</span><br>  <span>Quando usiamo il designer delle Sample Data Source viene creata una cartella SampleData nel progetto e per ogni Data Source una sotto cartella nella queale trovano posto 3 file:</span><br>  <ul>   <li>SourceName.xsd: definisce la struttura dei dati, è a tutti gli effetti il file che disegnate con il designer;</li>    <li><em>SourceName</em>.xaml: contiene i valori dei dati che verranno assegnati alle istanze delle classi definite in:</li>    <li><em>Sourcename</em>.xaml.cs: in cui vengono generate, direi a naso da un T4 template, le classi sulla base di ciò che avete disegnato nell’xsd;</li> </ul>  <span>Il tutto viene poi esposto al vostro mondo come risorsa nel file App.xaml.</span><br>  <span>E’ quindi facile fare una semplice prova replicando la situazione, fregandocene del file xsd, e costruendo la classe dei dati come meglio crediamo e scoprendo che possiamo usare quella perchè Blend la digerisce senza battere ciglio, mettendoci quindi tutti i tipi che vogliamo noi! :-) naturalmente perdiamo il supporto per il design della SampleDataSource ma direi che questo è il minore dei mali. Probabilmente smanettando un po’ con l’xsd si potrebbero fare cose decisamente interessanti mantenendo il supporto per il design anche della DataSource.</span><br>  <span>.m </span><br>

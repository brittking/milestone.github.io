---
layout: post
title: 'Jason: a way to handle the “C” of CQRS'
date: '2012-11-05T13:23:00.000+01:00'
author: Mauro Servienti
tags:
- Software Mason
- Jason
- CQRS
modified_time: '2012-11-05T13:23:00.242+01:00'
thumbnail: http://lh6.ggpht.com/-OYvKUhvQ59o/UGV246KFbuI/AAAAAAAACOQ/dhREYDq93EQ/s72-c/jason_thumb%25255B20%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-1704633801862202156
blogger_orig_url: http://milestone.topics.it/2012/11/jason-way-to-handle-c-of-cqrs.html
---

<p><a href="http://lh6.ggpht.com/-FrDBvJjvueE/UGV23u9uNEI/AAAAAAAACOI/aUyXBdT-iYQ/s1600-h/jason%25255B22%25255D.png"><img title="jason" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: left; padding-top: 0px; padding-left: 0px; margin: 0px 10px 10px 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="jason" align="left" src="http://lh6.ggpht.com/-OYvKUhvQ59o/UGV246KFbuI/AAAAAAAACOQ/dhREYDq93EQ/jason_thumb%25255B20%25255D.png?imgmax=800" width="86" height="60"></a></p> <p><a href="http://jason.codeplex.com/" target="_blank">Jason</a> is a small and simple infrastructure framework that aims to solve the commanding portion of CQRS giving to the developer a powerful infrastructure to introduce the command paradigm in the solution.</p> <p>Jason is composed of two main parts the server components and the client components.</p> <p>On the server side Jason can be hosted as a <a href="http://msdn.microsoft.com/en-us/library/dd456779.aspx" target="_blank">WCF</a> service or as a <a href="http://www.asp.net/web-api" target="_blank">MVC WebAPI</a> controller, thus the client can encompass from Silverlight clients to “Json” clients, such as a HTML/JQuery application, passing through all the .net application types you can think of that can issue a HTTP request using SOAP, Json or bare Xml.</p> <p><strong>Why commanding is so important?</strong></p> <p>Little digression…</p> <blockquote> <p>moving from an RPC (Remote Procedure Call) model, like the one proposed out-of-the-box by WCF (please notice the out-of-the-box meaning that is the default approach proposed, not the only one) to a request/response model (or command based model) allows the developer to easily define the bounds of each context and allows the developer to express much more strongly the intention of each action.</p> <p>The other important consideration is that I am speaking about the client –&gt; server communication direction where the client is asking the server to do something, for the server –&gt; client, e.g. when the client queries the server to read data, the standard WCF approach, or any other server technology that you can think of, to expose the read model is really a valid solution.</p></blockquote> <p><strong>Client side point of view</strong></p> <p>First of all let’s have a look at how stuff works with Jason from the client side point of view:</p> <blockquote> <div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">var factory = <span style="color: #0000ff">new</span> DefaultWorkerServiceClientFactory();<br><span style="color: #0000ff">using</span>( var client = factory.CreateAsyncClient() )<br>{<br>    var task = client.ExecuteAsync( <span style="color: #0000ff">new</span> PocoCommand() )<br>        .ContinueWith( r =&gt;<br>        {<br>            var e = r.Result <span style="color: #0000ff">as</span> PocoCommandResponse;<br>        } );<br><br>    task.Wait();<br>}</pre></div></blockquote>
<p>Trivial, isn’t it?</p>
<ul>
<li>we create a service client factory; 
<li>we use the factory to create an async (task based, thus <em>awaitable</em>) client; 
<li>issue a request to execute a command, that is a completely POCO class; 
<li>if we need we can wait for a response, that as the command can be a POCO class;</li></ul>
<p><strong>Wait a minute…</strong></p>
<p>Why the hell the DataContractSerializer does not complain about the unknown classes? if you are a long time WCF user you certainly know that every single type that we try to pass through the wire must be a well known type to the DataContractSerializer, and by default the serializer utilizes the service interface definition to determine which are the known types.</p>
<p><strong>A little lie</strong></p>
<p>In the above snippet a omitted the Jason configuration setup:</p>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">var config = <span style="color: #0000ff">new</span> DefaultJasonClientConfiguration( AppDomain.CurrentDomain.BaseDirectory, factory )<br>{<br>    CommandsSelector = t =&gt; <br>    {<br>        <span style="color: #0000ff">return</span> t.IsAttributeDefined&lt;DataContractAttribute&gt;()<br>            &amp;&amp; ( t.Name.EndsWith( <span style="color: #006080">"Command"</span> ) || t.Name.EndsWith( <span style="color: #006080">"CommandResponse"</span> ) ); <br>    }<br>};<br><br>config.Initialize();</pre><br></div></blockquote>
<ul>
<li>we create a default Jason configuration bound to: 
<ul>
<li>a crawling directory that will be scanned looking for Jason types (more on this later); 
<li>a client factory needed to support known types changes at runtime;</li></ul>
<li>we use a delegate to express which types, POCO types, must be treated as commands and thus must “meet” the DataContractSerializer; 
<li>in the end we initialize the configuration once, and only once;</li></ul>
<p><strong>Server side point of view</strong></p>
<p>From the server side point of view all you need to do is to define an handler for your command:</p>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #0000ff">class</span> PocoCommandHandler : AbstractCommandHandler&lt;PocoCommand&gt;<br>{<br>    <span style="color: #0000ff">protected</span> <span style="color: #0000ff">override</span> Object OnExecute( PocoCommand command )<br>    {<br>        <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> PocoCommandResponse();<br>    }<br>}</pre><br></div></blockquote>
<p>That’s it, the infrastructure (that as you may wonder must be configured) handles all the details for us and in the end calls the handler of the command. Inheriting from AbstractCommandHandler&lt;TCommand&gt; is not a requirement, simply saves us from some boiler plate code that ICommandHandler&lt;TCommand&gt; interface requires.</p>
<p><strong>Server side configuration</strong></p>
<p>Configuration, server side, starts from the assumption that we are using an Inversion of Control container (such as Castle Windsor) so the first thing to do is to register Jason required types into the container itself:</p>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">var windsor = <span style="color: #0000ff">new</span> WindsorContainer();<br><br>windsor.Register( Component.For&lt;IServiceProvider&gt;().Instance( windsor ) );<br>windsor.Register( Component.For&lt;ICommandHandlersProvider&gt;().ImplementedBy&lt;DefaultCommandHandlersProvider&gt;() );<br><br><span style="color: #008000">/*</span><br><span style="color: #008000"> * the WorkerService is required only if we want to host Jason using WCF</span><br><span style="color: #008000"> * so also the IJobHandlersProvider and IJobTaskHandlersProvider</span><br><span style="color: #008000"> */</span><br>windsor.Register( Component.For&lt;IJobHandlersProvider&gt;().ImplementedBy&lt;DefaultJobHandlersProvider&gt;() );<br>windsor.Register( Component.For&lt;IJobTaskHandlersProvider&gt;().ImplementedBy&lt;DefaultJobTaskHandlersProvider&gt;() );<br><br>windsor.Register( Component.For&lt;IWorkerService&gt;().ImplementedBy&lt;WorkerService&gt;() );</pre><br></div></blockquote>
<p>Let’s start from the simple stuff: WebAPI; in order to host Jason in a MVC WebAPI controller all we have to do is:</p>
<ul>
<li>Add a new ApiController to the solution; 
<li>Make the controller depend on the ICommandHandlersProvider Jason type;</li></ul>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> JasonController : ApiController<br>{<br>    <span style="color: #0000ff">readonly</span> ICommandHandlersProvider handlerProvider;<br><br>    <span style="color: #0000ff">public</span> JasonController( ICommandHandlersProvider handlerProvider )<br>    {<br>        <span style="color: #0000ff">this</span>.handlerProvider = handlerProvider;<br>    }<br>        <br>    <span style="color: #0000ff">public</span> HttpResponseMessage Post( Object command )<br>    {<br>        var handler = <span style="color: #0000ff">this</span>.handlerProvider.GetHandlerFor( command );<br>        var result = handler.Execute( command );<br><br>        <span style="color: #0000ff">return</span> Request.CreateResponse( HttpStatusCode.OK, result );<br>    }<br>}</pre><br></div></blockquote>
<p>As for the client in order to have everything up &amp; running we have to configure Jason:</p>
<blockquote>
<div id="codeSnippetWrapper"><pre id="codeSnippet" style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">var jasonConfig = <span style="color: #0000ff">new</span> DefaultJasonServerConfiguration( Path.Combine( AppDomain.CurrentDomain.BaseDirectory, <span style="color: #006080">"bin"</span> ) )<br>{<br>    RegisterAsTransient = ( c, i ) =&gt;<br>    {<br>        <span style="color: #0000ff">this</span>.windsor.Register<br>        (<br>            Component.For( c )<br>                .ImplementedBy( i )<br>                .LifeStyle.Is( Castle.Core.LifestyleType.Transient )<br>        );<br>    },<br>    CommandsSelector = t =&gt; <br>    { <br>        <span style="color: #0000ff">return</span> t.IsAttributeDefined&lt;DataContractAttribute&gt;() <br>            &amp;&amp; ( t.Name.EndsWith( <span style="color: #006080">"Command"</span> ) || t.Name.EndsWith( <span style="color: #006080">"CommandResponse"</span> ) ); <br>    }<br>};<br><br>jasonConfig.Initialize();</pre><br></div></blockquote>
<p>The configuration is really similar, except that we also provide a way for the configuration engine to use our own Inversion of Control container to register stuff required by Jason internally.</p>
<p>.m</p>  
---
layout: post
title: Report delle mie brame
date: '2009-03-26T05:32:00.000+01:00'
author: Mauro Servienti
tags:
- Why not...
modified_time: '2012-01-31T14:02:52.857+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-2295178307659363634
blogger_orig_url: http://milestone.topics.it/2009/03/report-delle-mie-brame.html
---

<span>Sintetizzo da subito quello che penso dei prodotti di reportistica attuali: “<em><a href="http://it.wikipedia.org/wiki/Ugo_Fantozzi" target="_blank">Una cag*ta pazzesca <cit.></a></em>” :-D, del resto lo penso da <a href="http://blogs.ugidotnet.org/topics/archive/2004/11/30/6383.aspx" target="_blank">tempo immemore</a>…</span><br>  <span>In questo senso l’accoppiata xaml/flow document/xps potrebbe avere un futuro notevole se nasceranno strumenti/designer e se verranno colmate alcune lacune non indifferenti, come ad esempio la mancanza del supporto per header e footer.</span><br>  <span>Guardando la mia esperienza di questi anni e osservando quello che vedo fare agli altri ho spesso la sensazione che ci si approcci al mondo reportistica in maniera totalmente errata e mi permetto di dire che anche gli strumenti che abbiamo a disposizione (aka designers) tendono a portarci fuori strada.</span><br>  <span>…potrei cominciare a pensare che il “designer visuale” è il vero male altro che il DataSet :-D</span><br>  <span>Un <em>report è una view</em> e come tale va trattato, ritengo penalizzante (e pure profondamente sbagliato) cercare di inserire logica all’interno del processo di rendering di un report, è un po’ come mettere logia nel processo di rendering di una <a href="http://martinfowler.com/eaaDev/PassiveScreen.html" target="_blank">view passiva</a> in un modello <a href="http://en.wikipedia.org/wiki/Model_View_Presenter" target="_blank">MVP</a>.</span><br>  <span>Il problema è che sempre più spesso mi capita di vedere che i designer dei report vengono utilizzati per creare, ad esempio, le join da cui poi scaturiscono i gruppi/breaking point all’interno del report, questo porta da un lato ad una penalizzazione delle performance e dall’altro ad una complessità di gestione assurda perchè quando ci vengono chiesti report un po’ strani, ed i clienti sono bravissimi a chiedere cose strane, facciamo i salti mortali all’interno del report.</span><br>  <span>La soluzione è decisamente sotto gli occhi di tutti ed è semplicemente quella di preparare dei <a href="http://martinfowler.com/eaaCatalog/dataTransferObject.html" target="_blank">DTO</a>, siano essi dei dto veri e propri, un dataset costruito ad hoc o una view sul db, che siano pensati solo ed esclusivamente per la reportististica e che siano quindi “piatti”, e ad esempio read-only, e lascino al report il solo onere di fare le operazioni di grouping.</span><br>  <span>Nel mio caso sto utilizzando i Reporting Services (sia rdl che rdlc) e mi trovo molto bene con i DataSet che vengono egregiamente digeriti dal designer di Visual Studio, quello che faccio è quindi modellare dei DataSet, generalmente con una sola DataTable (se vi ritrovate costretti ad usare più di una DataTable finirete con l’ìutilizzare i subreport e direi che potremmo classificarlo come uno <a href="http://en.wikipedia.org/wiki/Code_smell" target="_blank">smell</a>), che vengono “fillati” a runtime, in questo caso stiamo parlando quindi di report client (rdlc), utilizzando un adapter che è in grado di trasformare un grafo di oggetti di business nella sua rappresentazione per la reportistica.</span><br>  <span>Una cosa del tipo:</span><br>  <blockquote>   <span>class ReportManager<T> where T : IDomainEntity     <br>{      <br>   readonly IDataAdapter<T, DataTable> adapter;      <br>   public ReportManager( IDataAdapter<T, DataTable> adapter )      <br>   {      <br>      this.adapter = adapter;      <br>   }      <br>      <br>   public void ShowReport( T entity )      <br>   {      <br>      var rptData = this.adapter.Adapt( entity );      <br>      <br>      // … show the report …      <br>   }      <br>}</span><br> </blockquote>  <span>Sarà l’adaper che è in grado di scrorrere l’intero grafo e “trasformarlo” in una DataTable con quello che serve per il report.</span><br>  <span>.m</span><br>
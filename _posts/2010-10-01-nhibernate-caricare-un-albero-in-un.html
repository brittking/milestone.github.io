---
layout: post
title: 'NHibernate: caricare un albero in un singolo round-trip con il db'
date: '2010-10-01T08:00:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- NHibernate
modified_time: '2012-08-04T20:15:29.256+02:00'
thumbnail: https://lh5.googleusercontent.com/-UKSeKj-VcoQ/T0SkuxJ1IOI/AAAAAAAABww/CoMoXiyj_3A/s72-c/image%2525255B1%2525255D_thumb.png
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-1171306429313803461
blogger_orig_url: http://milestone.topics.it/2010/10/nhibernate-caricare-un-albero-in-un.html
---

<span>Supponiamo di avere una entità del dominio che rappresenta un albero, albero mappato e persistito con <a href="http://nhforge.org/" target="_blank">NHibernate</a>,  e abbiamo bisogno di caricare tutto l’albero in un singolo round-trip con il db.</span><br>  <span><a href="https://lh6.googleusercontent.com/-HtJBjSuWsbg/T0SkvvKrx0I/AAAAAAAABw4/opnl8oGwF0Q/image%2525255B1%2525255D.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: ; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image[1]" border="0" alt="image[1]" src="https://lh5.googleusercontent.com/-UKSeKj-VcoQ/T0SkuxJ1IOI/AAAAAAAABww/CoMoXiyj_3A/image%2525255B1%2525255D_thumb.png" width="260" height="144"></a></span><br>  <span>La soluzione proposta da <a href="http://ayende.com/Blog/archive/2009/08/28/nhibernate-tips-amp-tricks-efficiently-selecting-a-tree.aspx" target="_blank">Ayende</a> è indubbiamente ottima e funzionale, e non è obbligatorio usare hql funziona con qualsiasi sistema di query venga usato.</span><br>  <blockquote>   <pre style="margin-top: auto; font-family: ; margin-bottom: auto"><font face="Consolas"><span style="color: "><font style="font-size: 12pt" color="#0000ff">var</font></span><font style="font-size: 12pt"> tree = provider.CreateCriteria<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">	</font></font><font face="Consolas"><font style="font-size: 12pt">.List<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">	.Where( z => z.Parent == </font><span style="color: "><font style="font-size: 12pt" color="#0000ff">null</font></span><font style="font-size: 12pt"> )</font></font><br><font face="Consolas"><font style="font-size: 12pt">	.ToList();</font></font></pre>
</blockquote>

<span>Quello che succede è decisamente figoso, in sostanza quello che fate è limitarvi a caricare tutti i dati della tabella e lasciare che sia l’Identity Map della ISession a fare il resto del giochetto per voi; quello che non viene tenuto conto nella soluzione proposta, ma nessuno l’ha chiesto del resto, è la possibilità che in fase di query venga imposto un filtro: voglio l’albero con i soli nodi il cui nome inizia per “P”:</span><br>

<blockquote>
  <pre style="margin-top: auto; font-family: ; margin-bottom: auto"><font face="Consolas"><span style="color: "><font style="font-size: 12pt" color="#0000ff">var</font></span><font style="font-size: 12pt"> tree = provider.CreateCriteria<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">	</font></font><font face="Consolas"><font style="font-size: 12pt">.Add( </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Restrictions</font></span><font style="font-size: 12pt">.Like( </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"Name"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"P%"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">MatchMode</font></span><font style="font-size: 12pt">.Anywhere ) )<br><font style="font-size: 12pt"></font></font></font><font face="Consolas"><font style="font-size: 12pt">       .List<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">	.Where( z => z.Parent == </font><span style="color: "><font style="font-size: 12pt" color="#0000ff">null</font></span><font style="font-size: 12pt"> )</font></font><br><font face="Consolas"><font style="font-size: 12pt">	.ToList()</font></font><font face="Consolas"><font style="font-size: 12pt">;</font></font></pre>
</blockquote>

<span>Implementando la “Restriction” succede che il primo livello viene correttamente filtrato ma per i figli NHibernate emette degli statement sql che tornano sul db nonostante al primo giro i dati vengano filtrati correttamente, ragionandoci su ci rendiamo conto che alla fine ha ragione lui e il “problema” è abbastanza semplice da aggirare:</span><br>

<blockquote>
  <pre style="margin-top: auto; font-family: ; margin-bottom: auto"><font face="Consolas"><span style="color: "><font style="font-size: 12pt" color="#0000ff">var</font></span><font style="font-size: 12pt"> tree = provider.CreateCriteria<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">	</font></font><font face="Consolas"><font style="font-size: 12pt">.SetResultTransformer( </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Transformers</font></span><font style="font-size: 12pt">.DistinctRootEntity )</font></font><br><font face="Consolas"><font style="font-size: 12pt">	.CreateAlias( </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"ChildBranches"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"cb"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">JoinType</font></span><font style="font-size: 12pt">.LeftOuterJoin )</font></font><br><font face="Consolas"><font style="font-size: 12pt">	</font></font><font face="Consolas"><font style="font-size: 12pt">.Add( </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Restrictions</font></span><font style="font-size: 12pt">.Like( </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"Name"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"P%"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">MatchMode</font></span><font style="font-size: 12pt">.Anywhere ) )<br>       <font face="Consolas"><font style="font-size: 12pt">.Add( </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Restrictions</font></span><font style="font-size: 12pt">.Like( </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"cb.Name"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#a31515">"P%"</font></span><font style="font-size: 12pt">, </font><span style="color: "><font style="font-size: 12pt" color="#2b91af">MatchMode</font></span><font style="font-size: 12pt">.Anywhere ) )<br></font></font></font></font><font face="Consolas"><font style="font-size: 12pt">       .List<</font><span style="color: "><font style="font-size: 12pt" color="#2b91af">Branch</font></span><font style="font-size: 12pt">>()</font></font><br><font face="Consolas"><font style="font-size: 12pt">       .Where( z => z.Parent == </font><span style="color: "><font style="font-size: 12pt" color="#0000ff">null</font></span><font style="font-size: 12pt"> )</font></font><br><font face="Consolas"><font style="font-size: 12pt">       .ToList()</font></font><font face="Consolas"><font style="font-size: 12pt">;</font></font></pre>
</blockquote>

<span>Basta cioè propagare la condizione anche ai figli, a questo punto scopriamo che la ISession di NHibernate è veramente smart ed esegue correttamente il caricamento dell’albero facendo sempre e solo un round-trip verso il db.</span><br>

<span>.m</span><br>
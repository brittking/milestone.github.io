---
layout: post
title: IServiceContainer
date: '2008-05-25T09:44:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- Inversion of Control
modified_time: '2012-08-04T20:10:50.828+02:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-7329934954915404636
blogger_orig_url: http://milestone.topics.it/2008/05/iservicecontainer.html
---

<span>In <a href="http://blogs.ugidotnet.org/topics/archive/2008/05/16/il-database-egrave-al-mio-servizio.aspx" target="_blank">un'altro post</a> di qualche giorno fa mi è stato chiesto di approfondire alcuni concetti.</span><br>  <span>Partiamo dal primo: IServiceContainer.</span><br>  <span>Come forse avrete capito sono leggermente ossessionato dal problema delle dipendenze e siccome in moltissimi casi liberarsene costa veramente poco faccio sempre il possibile per farlo. Nello specifico in questo periodo stiamo facendo uso massiccio di <a href="http://www.castleproject.org/container/index.html" target="_blank">Castle Windsor</a> come motore di <a href="http://en.wikipedia.org/wiki/Inversion_of_Control" target="_blank">Inversion of Control</a> ma la mia ossessione mi dice che non è bello dipendere da Castle perchè domani mattina potremmo volerci mettere <a href="http://www.springframework.net/" target="_blank">Sping.NET</a> o <a href="http://www.codeplex.com/entlib" target="_blank">Unity</a>... quindi?!?!</span><br>  <span>Molto semplicemente astraimo l'uso che facciamo di Castle mascherandolo. In questo momento ci stiamo avvalendo solo delle funzionalità di IoC quindi abbiamo una semplice interfaccia:</span><br>  <span>public interface IServiceContainer    <br>{     <br>    T GetService<T>() where T : IService;  <br>    IService GetService( Type serviceType );  <br>    void Release( Object instance );     <br>}</span><br>  <span>l'applicazione a sua volta a runtime, sempre via IoC (ma con una implementazione custom non con Castle naturalmente), ottiene un'istanza di una classe concreta "<em>CastleServiceContainer</em>" che implementa l'interfaccia in oggetto.</span><br>  <span>public sealed class ServiceContainer : IServiceContainer    <br>{     <br>    private static IServiceContainer _instance = new ServiceContainer();     <br>    public static IServiceContainer GetContainer()     <br>    {     <br>        return _instance;     <br>    }     <br>    <br>    private ServiceContainer()     <br>    {     <br>        Type t = Type.GetType(Properties.Settings.Default.ServiceProviderType, true);     <br>        this.provider = Activator.CreateInstance(t) as IServiceContainer;     <br>    }     <br>    <br>    private IServiceContainer provider;     <br>    public T GetService<T>() where T : IService     <br>    {     <br>        return this.provider.GetService<T>();     <br>    }     <br>    <br>    public IService GetService( Type serviceType )     <br>    {     <br>        return this.provider.GetService( serviceType );     <br>    }     <br>    <br>    public void Release( Object instance )     <br>    {     <br>        this.provider.Release( instance );     <br>    }     <br>}</span><br>  <span>Infine abbiamo il "provider" vero e proprio, in questo caso quello che sfrutta (ed è l'unico che lo sa) Castle Windsor.</span><br>  <span>public class CastleServiceProvider : IServiceContainer    <br>{     <br>    IWindsorContainer container = null;     <br>    <br>    public CastleServiceProvider()     <br>    {     <br>        this.container = new WindsorContainer(     <br>            new XmlInterpreter(     <br>                new ConfigResource( "applicationSettings/ServiceProvider.Configuration" )     <br>            )     <br>        );     <br>    }     <br>    <br>    public T GetService<T>() where T : IService     <br>    {     <br>        return this.container.GetService<T>();     <br>    } </span><br>  <span>    public IService GetService( Type serviceType )    <br>    {     <br>        Object obj = this.container.GetService( serviceType );     <br>        return ( IService )obj;     <br>    }  <br>    <br>    public void Release( Object instance )     <br>    {     <br>        this.container.Release( instance );     <br>    }     <br>}</span><br>  <span>In questo modo l'applicazione sfrutta tutto quello che le serve senza sapere in realtà chi le sta fornendo questi servizi.</span><br>  <span>Quanto costa tutto ciò? forse, e ripeto forse, un pomeriggio di lavoro, se ci mettiamo che dal codice che ho postato ho rimosso la gestione delle Exception e il motore di tracing/logging; ma lo ritengo un pomeriggio decisamente ben speso! l'unico vero problema: farlo capire al cliente... ma questa è un'altra storia ;-)</span><br>  <span>.m</span><br>  
---
layout: post
title: Abuso di Inversion Of Control, Il container questo sconosciuto… e così deve
  essere!!
date: '2009-04-09T07:30:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- Inversion of Control
modified_time: '2012-01-31T14:04:03.691+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-5986291175171232259
blogger_orig_url: http://milestone.topics.it/2009/04/abuso-di-inversion-of-control-il.html
---

<span>ahahahrgh :-D</span><br>  <span>L’astrazione ha tanti vantaggi ma porta anche tanti potenziali problemi soprattutto se la stiamo gestendo male o se stiamo astraendo troppo o addirittura dove proprio non serve. L’uso di un container per IoC tende a portare ad un uso esasperato dell’astrazione perchè si tende, all’inizio, ad astrarre anche il container stesso.</span><br>  <span>L’inghippo è che probabilmente non abbiamo ben presente la differenza tra Dependency Injection e Inversion of Control, perchè se ne parla sempre insieme ma sono due mondo molto diversi tra loro dove il primo può vivere di vita propria mentre il secondo nasce anche per risolvere problematiche introdotte dal primo.</span><br>  <span>Faccio prima a fare un esempio:</span><br>  <blockquote>   <span>interface ISheafBuilder      <br>{       <br>    IEnumerable<ISheaf> BuildSheafs( IPublication publication, IEnumerable<IDelivery> deliveries );       <br>}</span><br> </blockquote>  <span>Un giornale quando va in stampa come prodotto finito ha dei “pacchi” di giornali che verranno consegnati, ad esempio alle edicole o agli abbonati, questi pacchi vengono creati seguendo un complesso dedalo di regole, regolette, regolucce e capricci (ad esempio le poste per le spedizioni massive hanno una quantità industriale di cavilli), una di queste regole recita più o meno:</span><br>  <blockquote>   <span>“… un pacco di giornali pronto per la consegna non deve pesare più di <em>xx</em> Kg…”</span><br> </blockquote>  <span>Questo banalmente perchè il trasportatore non deve morire per il peso…</span><br>  <span>Nell’insieme la regoletta è abbastanza banale, il peso di un giornale è calcolabile sulla base nel numero di pagine e quindi possiamo variare dinamicamente la dimensione dei pacchi di volta in volta:</span><br>  <blockquote>   <span>class SheafBuilder : ISheafBuilder      <br>{       <br>    public IEnumerable<ISheaf> BuildSheafs( IPublication publication, IEnumerable<IDelivery> deliveries )       <br>    {       <br>        //Bla… bla…       <br>    }       <br>}</span><br> </blockquote>  <span>… ma… se una volta realizzato il tutto qualcosa non va non sappiamo quale delle regole viene valutata “male/erroneamente” perchè tutto è all’interno di quel metodo BuildSheafs(), in soldoni non riusciamo a testare quello che succede dentro li. Sappiamo che fallisce ma non sappiamo perchè… <u>troppe responsabilità</u>.</span><br>  <span><strong>Single Responsability Principle</strong></span><br>  <span>Facciamo fare ad ognuno il suo lavoro ed introduciamo un nuovo attore:</span><br>  <blockquote>   <span>interface ISheafDimensionEvaluator      <br>{       <br>    Int32 EvaluateMaxSheafDimension( Int32 pagesCount );       <br>}</span><br> </blockquote>  <span>Abbiamo quindi un tizio che è in grado di dirci la dimensione massima di un pacco date il numero di pagine di una pubblicazione. Introduciamo una dipendenza e spieghiamo al mondo che il nostro SheafBuilder ha bisogno di questo nuovo signore per lavorare:</span><br>  <span><strong>Dependency Injection</strong></span><br>  <blockquote>   <span>class SheafBuilder : ISheafBuilder      <br>{       <br>    readonly ISheafDimensionEvaluator evaluator;       <br>    public SheafBuilder( ISheafDimensionEvaluator evaluator )       <br>    {       <br>        this.evaluator = evaluator;       <br>    }       <br>    <br>    public IEnumerable<ISheaf> BuildSheafs( IPublication publication )       <br>    {       <br>        var maxDim = this.evaluator.EvaluateMaxSheafDimension( publication.PagesCount );       <br>        //Bla… bla…       <br>    }       <br>}</span><br> </blockquote>  <span>Questa è DI, nulla di più, iniettiamo le dipendenze. <u>Il tutto funziona a prescindere dalla presenza di un container per IoC</u>:</span><br>  <blockquote>   <span>var evaluator = new SheafDimensionEvaluator();      <br>var builder = new SheafBuilder( evaluator );</span><br>    <span>var sheafs = builder.BuildSheafs( … );</span><br> </blockquote>  <span><strong>Inversion Of Control</strong></span><br>  <span>Certo è che se estendiamo la soluzione proposta a tutto il nostro mondo la cosa si complica non poco…è evidente. Un service container ci viene allegramente in aiuto fornendoci un ottimo motore di risoluzione delle dipendenze, e molto altro:</span><br>  <blockquote>   <span>var container = new WindsorContainer();      <br>container.Register( Component.For<ISheafBuilder>()       <br>                                                  .ImplementedBy<SheafBuilder>() );       <br>container.Register( Component.For<ISheafDimensionEvaluator>()       <br>                                                  .ImplementedBy<SheafDimensionEvaluator>() );</span><br> </blockquote>  <span>la prima cosa che facciamo sarà quindi istruire il container su come è fatto il nostro mondo… e poi potremo allegramente, allegri oggi eh… ti spiego… week-end lungo in arrivo :-D, fare:</span><br>  <blockquote>   <span>var builder = container.Resolve<ISheafBuilder>();      <br>var sheafs = builder.BuildSheafs( … );</span><br> </blockquote>  <span>Molto meglio, decisamente, soprattutto se pensiamo su larga scala.</span><br>  <blockquote>   <span>Un motore di inversion of control è quindi qualcuno a cui possiamo chiedere qualcosa sapendo che se questo qualcosa ha delle dipendenze sarà onere ed onore del motore risolverle.</span><br> </blockquote>  <span>Gli esempi su IoC che troviamo, in quanto esempi, sono sempre molto semplici e, spesso, si riducono a qualcosa del tipo:</span><br>  <blockquote>   <span>var container = new WindsorContainer();      <br>var notifier = container.Resolve<INotifier>();</span><br>    <span>notifier.Notify( “Hello world!” );</span><br> </blockquote>  <span>Guardando gli esempi triviali e leggendo qua e la la prima cosa a cui si pensa è che il container in quanto tale è uno ed uno solo per ciclo di vita dell’applicazione (e questo è giustissimo) e da buoni pattern-addicted quali siamo l’equazione ci dice: <em>singleton…e qui casca l’asino</em> ;-)</span><br>  <span>Quando ci troviamo di fronte alla prima applicazione di un certo peso e decidiamo tutti orgogliosi che <u>dobbiamo</u> usare un container per IoC, memori della pensata di cui sopra, la prima cosa che facciamo è costruire una cosa del tipo:</span><br>  <blockquote>   <span>static class DependencyContainer      <br>{       <br>    public static IDependencyContainer GetContainer(){ /* singleton malefico ;-) */ }       <br>}</span><br> </blockquote>  <span>IDependencyContainer è un <a href="http://www.codeplex.com/CommonServiceLocator" target="_blank">proxy generico</a> verso un qualsiasi container sul mercato, nulla di trascendentale anzi. In questo modo possiamo facilmente fare:</span><br>  <blockquote>   <span>public IEnumerable<ISheaf> BuildSheafs( IPublication publication )      <br>{       <br>    var maxDim = this.evaluator.EvaluateMaxSheafDimension( publication.PagesCount );       <br>    //Bla… bla…       <br>    var container = DependencyContainer.GetContainer();       <br>    var svc = container.Resolve<…>();       <br>}</span><br> </blockquote>  <span>Tutti <a href="http://www.etimo.it/?term=tronfio" target="_blank">tronfi</a> guardiamo quello che abbiamo fatto e potremmo essere portati a pensare che è una vera figata:</span><br>  <ul>   <li>abbiamo una classe <u>static</u>a che espone il nostro amato e inseparabile <u>singleton</u> ;-) </li>    <li>recuperiamo dove ci serve il container e gli chiediamo di risolvere una dipendenza senza tante menate di costruttori e proprietà pubbliche; </li>    <li>abbiamo astratto a sua volta anche il container, ci vogliono circa 30 minuti per farlo; </li> </ul>  <span>Astrarre il container di per se è cosa inutile, sarebbe come dire voglio astrarmi dalla classe String… il container è infrastruttutura e come tale se serve deve essere noto dove serve. Inoltre se volete andare oltre le funzionalità di base, che già sono molte, c’è poco da fare ogni container, ad esempio, fa AOP/Policy Injection a modo suo e quindi dovete fare una scelta per la vita ;-)</span><br>  <span>Ma se siete un <em>framework guy</em> non potete permettervi una dipendenza dal container perchè obblighereste chi usa il vostro prodotto a dipendere da quello specifico container. Come abbiamo visto la soluzione è decisamente semplice basta configurare correttamente le dipendenze dei singoli componenti, ma è sempre così facile?… abbiate pazienza, ci torniamo.</span><br>  <span><u>Perchè quello che abbiamo fatto nella realtà dei fatti è IL MALE?</u> ;-)</span><br>  <span>Bhe… provate a testare quella roba… impossibile se non facendo i salti mortali per avere l’ambiente di test configurato correttamente, inoltre violate uno dei principi basilari dello Unit Testing: l’indipendenza dei singoli test, infatti la classe statica fa si che un secondo test si ritrovi il container già configurato… male, molto male.</span><br>  <span>Abbiamo però detto che non è sempre possibile risolvere ogni singola situazione con DI, ammetto che per ora a me è capitato solo 2 volte; vediamo un esempio:</span><br>  <blockquote>   <span>Nella vostra fantastica applicazione basata su <a href="http://blogs.ugidotnet.org/topics/category/3551.aspx" target="_blank">Composite UI</a> siete in ascolto di un <a href="http://blogs.ugidotnet.org/topics/archive/0001/01/01/imessagebroker.aspx" target="_blank">messaggio</a> e, sulla base di alcuni parametri del messaggio in arrivo, dovete visualizzare una certa window/viewModel piuttosto che un altra, quindi dovete prendere questa decisione a runtime.</span><br>    <span>In questo semplice esempio probabilmente avrete una classe preposta alla gestione del messaggio e non potete certo iniettare tutti i possibili viewModel, anche perchè potreste avere la necessità di visualizzare più volte la stessa UI contemporaneamente, ecco quindi che dovete avere la possibilità di accedere ad <em>n</em> istanze diverse direttamente a runtime.</span><br> </blockquote>  <span>La soluzione più semplice è iniettare il container stesso ;-), in fase di registrazione dei componenti potete fare:</span><br>  <blockquote>   <span>var container = new WindsorContainer();     <br>container.Register( Component.For<IWindsorContainer>()      <br>                                                  .Instance( container )      <br>                                                  .ListStyle.Is( LisfeStyle.Singleton ) );</span><br> </blockquote>  <span>e quindi far dipendere il vostro componente dal container:</span><br>  <blockquote>   <span>class MyComponent     <br>{      <br>    public MyComponent( IWindsorContainer container )      <br>    {      <br>        //bla… bla…      <br>    }      <br>}</span><br> </blockquote>  <span>Questo è <em>molto</em> testabile perchè nel test potete facilmente mockare quel IWindsorContainer. Ma a questo punto i puristi potrebbo obiettare che tutta la nostra applicazione dipende da quello specifico container e non hanno tutti i torti, sempre che abbia senso astrarre così tanto. Vediamo perchè:</span><br>  <ul>   <li>MyApplication.System     <br><em>Contiene i contratti e non dipende da nessuno;</em></li>    <li>MyApplication.Runtime     <br><em>Contiene l’implementazione dei contratti, non dovrebbe dipendere dal container pena l’impossibilità di rimpiazzare il container con facilità. Ma se dobbiamo iniettare il container stesso qui abbiamo una dipendenza.</em></li>    <li>MyApplication.Bootstrap     <br><em>Dipende dal container, e va bene è l’entry point…</em></li> </ul>  <span>La soluzione più semplice è sotto i nostri occhi sin dal lontano 2001, nel framework infatti è ben noto da tempo il concetto di IoC: System.IServiceProvider, e i container blasonati (tra cui Castle Windsor) implementano quell’interfaccia… ergo:</span><br>  <blockquote>   <span>var container = new WindsorContainer();     <br>container.Register( Component.For<IServiceProvider>()      <br>                                                  .Instance( container )      <br>                                                  .ListStyle.Is( LisfeStyle.Singleton ) );</span><br>    <span>class MyComponent     <br>{      <br>    public MyComponent( IServiceProvider container )      <br>    {      <br>        //bla… bla…      <br>        var svc = container.GetService( typeof( IMyService ) ) as IMyService;      <br>    }      <br>}</span><br> </blockquote>  <span>L’unica cosa che ci perdiamo è un po’ di sintassi <em>cool</em> con i generics. Ma non solo, purtroppo IServiceProvider è molto scarna come funzionalità quindi se avete bisogno di fare qualcosa di più della semplice Resolve/GetService siete nuovamente a piedi.    <br>Inoltre dal punto di vista del design la soluzione di iniettare il conatiner introduce un potenziale problema derivante dal fatto che stiamo dando in mano al singolo componente la possibilità di fare tutto e controllare che faccia solo ciò che deve è un po’ complesso.</span><br>  <span><strong>Factory, factory, factory</strong></span><br>  <span>Ma non tutto è perso, anzi, possiamo fare molto meglio, nell’esempio di prima perchè non fare:</span><br>  <blockquote>   <span>interface IMyServiceProvider     <br>{      <br>    T Resolve<T>() where T : IMyServiceBase      <br>}</span><br>    <span>class MyComponent     <br>{      <br>    public MyComponent( IMyServiceProvider provider )      <br>    {      <br>        //bla… bla…      <br>        var svc = provider.Resolve<IMyService>();      <br>    }      <br>}</span><br> </blockquote>  <span>In questo modo otteniamo nuovamente:</span><br>  <ul>   <li>Dependency Injection, e quindi facilità di test;</li>    <li>Sintassi figosa con i generics;</li>    <li>possiamo esporre tutte le funzionalità necessarie;</li>    <li>controllo su quello che MyComponent può fare;</li> </ul>  <span>Quello che ci manca adesso è semplicemente un’implementazione di IMyServiceProvider che dipenda dal container, per ovviare al problema della dipendenza, visto che usiamo IoC potremmo isolare questo provider in un assembly a se e quindi portarci a casa comunque la possibilità di rimpiazzare facilmente il container.</span><br>  <span>Direi che ho finito… :-D, l’argomento è complesso e credo che solo “<em>lo sbatterci il muso</em>” possa farvi veramente capire quali sono i problemi e quali le soluzioni migliori e a quale prezzo.</span><br>  <span>Adesso come al solito non sparate sul pianista…</span><br>  <span>.m</span><br>  
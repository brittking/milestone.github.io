---
layout: post
title: Ma mi facci il “Servizio” <semi-cit.>
date: '2010-04-16T23:16:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- SOA
- Architecture
modified_time: '2012-08-04T20:21:09.711+02:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-5312294359685955003
blogger_orig_url: http://milestone.topics.it/2010/04/ma-mi-facci-il-servizio.html
---

<blockquote>   <span><em>Serializzare un Expression Tree e spedirlo al server per deserializzarlo e aspettarsi dei risultati è tutto quello che volete ma non è di certo qualcosa che ha a che fare con SOA :-)</em></span><br> </blockquote>  <span><strong>SOA: <a href="http://msdn.microsoft.com/en-us/library/ms954638.aspx" target="_blank">4 tenets</a></strong></span><br>  <ol>   <li>Boundaries are explicit;</li>    <li>Services are autonomous;</li>    <li>Services share schema and contract, not class;</li>    <li>Service compatibility is based upon policy;</li> </ol>  <span><strong>Mindmapping… aka elucubrazioni :-)</strong></span><br>  <span>Diciamo che avete questo scenario, per noi a oggi decisamente concreto:</span><br>  <ul>   <li>A prima vista la necessità sembrava quella di dover realizzare una “<em>becera</em>” applicazione client-server; </li>    <li>poi scoprite che l’utilizzatore finale avrà qualche “<em>decinaia</em>” di installazioni sparse per i nostro piccolo mondo… uno piccolino insomma :-) </li> </ul>  <span>è lecito secondo voi farsi queste domande?</span><br>  <ol>   <li>è ipotizzabile che gli aggiornamenti dei client, dei server o di entrambi non siano contemporanei? quindi è uno scenario plausibile che ci siano in esecuzione contemporaneamente versioni diverse del client o del server senza che questi lo sappiano?</li>    <li>è sensato pensare che il repository dei dati sia uno ed uno solo per tutto il mondo? </li>    <li>è sensato pensare che 2 richieste consecutive, verso lo strato dei servizi, vengano evase dallo stesso server? </li>    <li>è sensato pensare che ci possa essere una richiesta che viene evasa con successo ma che non da una risposta nonostante il chiamante se la aspetti? </li>    <li>e… di conseguenza è sensato pensare che il client possa riprovare “all’infinito” finchè non ottiene la risposta che gli interessa senza che questo “<em>sminchi</em>” (termine molto tecnico) tutto? </li> </ol>  <span>Se vi fate queste domande e se rispondete “si, no, no, si, si” allora probabilmente un’architettura basata su principi SOA è la vostra “soluzione”.</span><br>  <span><strong>Un contratto è per sempre…</strong></span><br>  <span>Dicamo che i punti 2, 3, 4 e 5 sono probabilmente “seghe mentali”, ma vanno analizzati a fondo e soprattutto qualcuno mi deve mettere nero su bianco le risposte (<em>ciò che non è scritto non è mai stato detto <cit.></em>), il primo punto però in un’applicazione geograficamente distributia è decisamente plausibile.</span><br>  <blockquote>   <span>Come possiamo gestire il fatto che in un determinato momento <em>t</em> un client in America Latina faccia una chiamata ad un “metodo” di un servzio in Europa e che la firma di questo metodo sia radicalmente diversa da come il client si aspetta?</span><br> </blockquote>  <span><strong>Problemi…</strong></span><br>  <span>Mixxando il mio modo di vedere le cose e le fantastiche uscite di Giorgio ,collega in <a href="http://www.gaia.is.it/" target="_blank">Gaia</a> e compagno di banco, direi:</span><br>  <blockquote>   <span><em>i problemi sono come il cucchiaio, non esistono… :-)</em></span><br> </blockquote>  <span>Se ci pensiamo stiamo affrontando il <em>problema</em> dalla parte sbagliata, lo stiamo affrontando con la “vision” (in questo caso ottusa) dello sviluppatore che è fossilizzato sul chiamare un metodo di un’istanza.</span><br>  <span>E’ Visual Studio che ci trae in inganno, o meglio svcutil.exe, generando un “<em>robo</em>” che ci permette di invocare metodi e aspettarci eventuali valori di ritorno, in realtà sotto sotto un servizio ragiona solo ed esclusivamente a “messaggi”:</span><br>  <ul>   <li>Un messaggio viaggia dal client verso il server;</li>    <li>Un messaggio viaggia dal server verso il client;</li> </ul>  <span>Nulla di più ne nulla di meno, cosa ci limita nell’usare lo stesso approccio? o meglio, nell’usare il servzio con chiamate a basso livello? nulla, se non la nostra <u>sanissima</u> abitudine alla tipizzazione forte, e magari un po’ di pigrizia… ;-)</span><br>  <span>Se però ci pensiamo è proprio quello che ci serve:</span><br>  <ul>   <li>il client prepara un messaggio di un certo tipo;</li>    <li>qualcosa serializza quel messaggio di un certo tipo in qualcosa di un certo tipo che però è spedibile “on the wire”;</li>    <li>un server riceve il blobbone e delega a qualcuno di deserializzare il tutto in un messaggio di un certo tipo;</li>    <li>il server analizza il messaggio e la versione e decide se, e come, farne routing verso un altro server;</li>    <li>il ricevente delega a qualcuno l’onere di processare il messaggio;</li>    <li>il tutto procede in senso inverso se c’è un’eventuale risposta;</li> </ul>  <span>Provate a condire questa cosa con un bel po’ di sano IoC e di DI e ottenete una cosa che almeno sulla carta è decisamente figosa. Vantaggi:</span><br>  <ol>   <li>Avete comunque una tipizzazione molto forte;</li>    <li>Avete controllo totale sul versioning, sul routing e sul dispatching in maniera totalmente trasparente;</li>    <li>potete atomicizzare/serializzare un set di messaggi;</li> </ol>  <span>Svantaggi:</span><br>  <ol>   <li>Se lo dovete dare in mano ad un <em>rookie</em> dovete sbattarvi non poco per rendere <em>rookie-developer-firendly</em> il tutto, ma i gioco, imho, vale decisamente la candela;</li>    <li>… nonzo :-)</li> </ol>  <span><strong>Live!</strong></span><br>  <span>voci di corridoio mi dicono che ne parleremo dal vivo, Giorgio ed Io, probabilmente in 2 occasioni una prima dell’estate e una in autunno, stay tuned ;-)</span><br>  <span>.m</span><br>  
---
layout: post
title: 'UI Composition :: Il processo di discovery'
date: '2009-04-01T04:18:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- Architecture
- UI Composition
modified_time: '2012-01-31T14:03:45.356+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-4235945040970825447
blogger_orig_url: http://milestone.topics.it/2009/04/ui-composition-il-processo-di-discovery.html
---

<span>La <a href="http://blogs.ugidotnet.org/topics/archive/2009/03/31/ui-composition-la-shell.aspx" target="_blank">nostra applicazione</a> non fa ancora nulla ma almeno si <a href="http://downloads.topics.it/composite_ui_samples/CompositeUI_v1.zip" target="_blank">avvia</a>.</span><br>  <span>Il prossimo passo è quello di realizzare un’infrastruttura per gestire i moduli, in particolare in questa fase ci concentreremo sul processo di discovery.</span><br>  <span>Quali sono i problemi che dobbiamo risolvere:</span><br>  <ul>   <li><strong>Discovery</strong>: il processo di discovery è quello che consente all’IApplicationBootstrapper di capire quali siano i moduli che possono essere caricati, quello che ci dobbiamo limitare a fare è quindi fornire allo strato superiore l’elencodeii moduli disponibili, non è onere nostro fare nessun ragionamento; </li> </ul>  <span>A questo punto possiamo avere 3 potenziali problemi:</span><br>  <ul>   <ol>     <li>Un requisito potrebbe essere che l’utente deve poter scegliere se caricare o meno un certo modulo; </li>      <li>Potremmo introdure il concetto di moduli “esclusivi”, quindi un solo modulo di tipo esclusivo può essere caricato; </li>      <li>Potremmo aver bisogno di fare ragionamenti sulla base dei moduli disponibili e prendere decisioni su cosa caricare e in che modo; </li>   </ol>    <li><strong>Descriptors Loading</strong>:  i potenziali scenari descritti ci obbligano a scindere le informazioni che descrivono il modulo e ad “esternalizzarle” dall’assembly che definisce il modulo stesso, in questo modo possiamo evitare di caricare nell’AppDomain l’assembly, dato che poi non potremmo scaricarlo, e possiamo evitare di mettere in piedi complessi castelli per effettuare il caricamento in un AppDomain diverso da quello del chiamante; </li> </ul>  <span><strong>Discovery & Descriptors Loading</strong></span><br>  <span>Il processo di discovery, come abbiamo detto, è l’atto di scoprire quali siano i moduli installati, potremmo sintetizzarlo così:</span><br>  <blockquote>   <span>var moduleManager = serviceContainer.Resolve<IModuleManager>();      <br>var installedModules = moduleManager.GetInstalledModules();</span><br> </blockquote>  <span>Il metodo GetInstalledModules() ci ritorna una IEnumerable<IModuleDescriptor>; una classe che implementa IModuleDescriptor altro non è che una banalissima classe che contiene informazioni relative ad un determinato modulo, ora come ora semplicemente:</span><br>  <blockquote>   <span>interface IModuleDescriptor      <br>{       <br>   String Name{ get; }       <br>}</span><br> </blockquote>  <span>banale direi, per ora del resto non ci serve altro.</span><br>  <span>Il processo di caricamento dei ModuleDescriptor(s) è implementato utilizzando come repository, della configurazione dei moduli installati, il file di configurazione dell’applicazione stessa. Quindi, nella nuova versione della solution, trovete un’implementazione di IModuleManager che dipende da una ConfigurationSection (System.Configuration) che è in grado di gestire le informazioni persistite all’interno del file app.config.</span><br>  <span>Quindi quello che trovate è:</span><br>  <ul>   <li><em>ModuleDescriptor</em>: implementa l’interfaccia IModuleDescriptor e espone informazioni, descrittive, relative ad un modulo; </li>    <li><em>ConfigSectionModuleManager</em>: implementa l’interfaccia IModuleManager e gestisce, per ora, il solo discovery dei moduli installati, ConfigSectionModuleManager dipende dalla configurazione presente nel file app.config dell’applicazione; </li>    <li><em>ModulesConfigurationSectionHandler</em>: implementa la logica per deserializzare le informazioni custom presenti nel file di configurazione relative ai moduli installati;       <ul>       <li><em>ModuleElement</em> e <em>ModuleCollectionElement</em> gesticono, rispettivamente, il singolo elemento definito all’interno del file di configurazione e una lista di elementi; </li>     </ul>   </li> </ul>  <span>Ho infine introdotto il primo servizio “applicativo” che potrà essere utilizzato da tutti i moduli e dalla Shell stessa:</span><br>  <ul>   <li><em>IEnvironmentService</em>: che in questo momento consente di accedere alla lista dei moduli installati; </li> </ul>  <span>Naturalmente l’altra variazione di rilievo è nel progetto MyApplication.Boot in cui abbiamo aggiornato la configurazione di Castle Windsor al fine di fargli gestire il discovery dei nuovi servizi.</span><br>  <span>Allego il progetto con le modifiche descritte: <a href="http://downloads.topics.it/composite_ui_samples/CompositeUI_v2.zip" target="_blank">CompositeUI_v2.zip</a></span><br>  <span>C’è infine un nuovo progetto, Castle.Extensibility, non contiene altro che una extension che serve per gestire in maniera più umana le factory con Castle Windsor, il codice, peraltro molto semplice, non è frutto del mio sacco ma sinceramente non ricordo dove l’ho trovato quindi non posso citare la fonte, mi spiace.</span><br>  <span>.m</span><br>    
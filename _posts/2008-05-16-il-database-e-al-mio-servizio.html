---
layout: post
title: Il database è al mio servizio...
date: '2008-05-16T09:51:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
- Architecture
modified_time: '2012-01-28T11:31:22.804+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-1282832643050276290
blogger_orig_url: http://milestone.topics.it/2008/05/il-database-e-al-mio-servizio.html
permalink: /2008/05/il-database-e-al-mio-servizio.html
---

<span>... e non viceversa. Con questo intendo dire che il modello ad oggetti che utilizziamo non dovrebbe essere mai modellato, in nessuna delle sue parti, pensando al fatto che quello specifico modello ad oggetti dovrà essere mappato su di un modello relazionale.</span><br>  <span>Perchè dico questo? perchè spesso vedo, o semplicemente sento, che questo concetto viene in alcuni casi "dimenticato" a favore della semplicità (ma è poi vera questa semplicità o è solo apparente?) di implementazione della relazione tra i due mondi.</span><br>  <span>Ma andiamo con ordine, ieri "chiaccherando" di architettura con il collega Marco, sono stato simpaticamente tacciato di farmi un sacco si "<em>segh* mentali</em>" ed io candidamente ho riposto che se il mio lavoro potesse essere fatto di magagne architetturali e segh* mentali che devono portare ad una soluzione elegante, performante e di semplice utilizzo sarei felicissimo. Quando ci sono problemi tecnici da risolvere io sono effettivamente a mio agio e sotto pressione poi rendo anche parecchio.</span><br>  <span>Perchè sono stato additato come "puntiglioso"? perchè eravamo di fronte al classico problema di dover gestire il rapporto del nostro modello ad oggetti con il database nel momento in cui di mezzo c'è una relazione "molti a molti".</span><br>  <span>Facciamo un esempio, decisamente simile alla realtà dei fatti, immaginiamo di avere una rappresentazione in memoria di un albero con però ha la caratterisitca che questo albero oltre ad avere la classica relazione padre-figlio/i ha anche la possibilità di avere, come "figli" di un nodo, dei <em>link</em> ad altri nodi, potremmo paragonarli ai link che su filesystem metteremmo in una folder per puntare ad un'altra folder sempre su filesystem.</span><br>  <span>Il nostro modello è quindi così rappresentabile:</span><br>  <span>interface INode    <br>{     <br>    INode Parent { get; }     <br>    String Name { get; set; }     <br>    INodeList Nodes { get; }     <br>    INodeList Links { get; }     <br>}     <br>    <br>interface ITree : INode     <br>{     <br>}</span><br>  <span><em>faccio notare come sia Nodes che Links abbiano lo stesso tipo di ritorno</em>.     <br>Questo modello, nello specifico la collection Links, è una classica relazione molti a molti che sul db possiamo rappresentare con una tabella di ponte: "NodesTable" <--> "Links" <--> "NodesTable", dove in Links abbiamo la PK della <em>Source</em> e la PK della <em>Destination</em>.</span><br>  <span>In molti casi lo sviluppatore si <em>arrende</em> e per rappresentare quella relazione modella il suo dominio come se lo <em>trova</em> sul db, quindi modella una entità INodeLink, con la relativa collection, ed espone quella, ma questa cosa anche se <u>non necessariamente sbagliata</u> <u>secondo me</u> è comunque una di quelle cose che <u>potrebbero</u> ricadere sotto il cappello del "<em>code smell</em>". Sia chiaro ci sono dei casi in cui questo modello ha decisamente senso, anche se anche qui ci sono soluzioni probabilmente più eleganti, pensiamo ad esempio alla relazione "Studenti <--> EsamiSostenuti <--> Esami" in cui abbiamo bisogno di aggiungere informazioni (metadati?) oltre alla semplice relazione.</span><br>  <span>Tutto questo per arrivare a fare una cosa che per lo sviluppatore è decisamente naturale, e cioè una cosa del tipo:</span><br>  <span>ITree sourceTree = null;    <br>ITree destTree = null;     <br>    <br>IServiceContainer sc = ServiceContainer.GetContainer();     <br>using( ITreeDataProvider dp = sc.GetService<ITreeDataProvider>() )     <br>{     <br>    sourceTree = dp.GetByKey( <em>pk</em> );     <br>    destTree = dp.GetByKey( <em>pk</em> );     <br>}     <br>    <br>INode sourceNode = sourceTree.Nodes[ 0 ];     <br>INode destNode = destTree.Nodes[ 3 ];     <br>sourceNode.Links.Add( destNode );     <br>    <br>IChangeSet cSet = null;     <br>using( IChangeTrackingService<ITree> ctSvc = sc.GetService<IChangeTrackingService<ITree>>() )     <br>{     <br>    cSet = ctSvc.GetChangeSet( sourceTree );     <br>}     <br>    <br>using( IUnitOfWork uow = sc.GetService<IUnitOfWork>() )     <br>{     <br>    uow.Append( cSet );     <br>    uow.Commit();     <br>    cSet.AcceptChanges();     <br>}     <br>    <br>il bello è che funziona pure... e vista l'architettura che abbiamo messo in piedi ci sono volute un paio d'ore (dalla stesura delle classi alla creazione delle tabelle/sp sul db) per introdurre il "<em>concetto</em>" nel nostro mondo.     <br>Direi che anche oggi (o meglio stamattina dalle 4.30 alle 6.30) ci siamo guadagnati una parte della pagnotta, che abbiamo poi consumato con il consueto training fisico mattutino... </span><br>  <span><em>il mattino ha l'oro in bocca, il mattino ha l'oro in bocca, il mattino ha l'oro in bocca <cit.></em>, che debba comiciare a preoccuparmi?     <br>Noooooo finchè non chiamo <a href="http://blogs.ugidotnet.org/pape" target="_blank">Andrea</a> "<em>Wendy</em>" direi che non ci dovrebbero essere problemi :-D</span><br>  <span>Detto questo direi che è doveroso ricordare che se vi può interessare capire cosa c'è dietro quegli snippet di codice siete i benvenuti: "<a href="http://blogs.ugidotnet.org/topics/archive/2008/05/01/offerta-di-lavoro.aspx" target="_blank">cercasi</a>".</span><br>  <span>.m</span><br>  

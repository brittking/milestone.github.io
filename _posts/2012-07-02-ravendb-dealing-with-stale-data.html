---
layout: post
title: 'RavenDB: dealing with stale data'
date: '2012-07-02T09:59:00.001+02:00'
author: Mauro Servienti
tags:
- RavenDB
modified_time: '2012-07-02T09:59:08.786+02:00'
thumbnail: http://lh6.ggpht.com/-RZaSgK254_o/T_FUuKy04cI/AAAAAAAACBw/atvs67P4eMc/s72-c/image_thumb.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-5929815780529688458
blogger_orig_url: http://milestone.topics.it/2012/07/ravendb-dealing-with-stale-data.html
permalink: /2012/07/ravendb-dealing-with-stale-data.html
---

<p>One of the hardest concept to take on board when dealing with a document database like <a href="http://ravendb.net" target="_blank">RavenDB</a> is the concept of stale data.</p> <p>First of all one a couple of facts:</p> <ul> <li>RavenDB is a transactional, ACID, database (period).</li> <li>we are deeply used to staleness (even if we do not realize), every single piece of information we “see” is stale by design, it is a picture of the past;</li></ul> <p>As we have <a href="{{ site.baseurl }}{% post_url 2012-05-29-ravendb-i-want-my-data %}" target="_blank">already introduced</a> RavenDB in order to query data needs an index, so in order to look for the following document:</p> <p><a href="http://lh5.ggpht.com/-VOegi1qNvlM/T_FUs1ZwU0I/AAAAAAAACBo/JqYx_QGzDZI/s1600-h/image%25255B2%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh6.ggpht.com/-RZaSgK254_o/T_FUuKy04cI/AAAAAAAACBw/atvs67P4eMc/image_thumb.png?imgmax=800" width="210" height="244"></a></p> <p>we cannot express a query, well we can because in RavenDB there is the dynamic index feature that under the hood automatically creates an index for us, such as the following:</p> <blockquote> <p>var query = from person in docs.People<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where person.FirstName == “Mauro” &amp;&amp; person.Address.City.StartsWith( “f” )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select person;</p></blockquote> <p>we cannot simply because we need to define an index that tells to the database engine where we want to search, something like this:</p> <p><a href="http://lh3.ggpht.com/-kxLeofcQFw8/T_FUvEOdHgI/AAAAAAAACB4/yzmyFUTvfC0/s1600-h/image%25255B7%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-6RckHhw1-yI/T_FUwQpQa7I/AAAAAAAACCA/oqxD0N0fcH0/image_thumb%25255B3%25255D.png?imgmax=800" width="464" height="158"></a></p> <p>We are using the linq query syntax to express the index definition, in which we tell:</p> <ol> <li><em>docs.People</em>: use all the documents from the “People” collection;</li> <li><em>FirstName = doc.FirstName</em>: index the FirstName field on each document;</li> <li><em>Address_City = doc.Address.City</em>: index the nested field City on each nested Address document, the “_” is the convention to map nested fields;</li></ol> <p>Now if we issue the above query from the studio using the Lucene syntax we get the expected results:</p> <p><a href="http://lh4.ggpht.com/-AWJSQsN8_34/T_FUxQBFkRI/AAAAAAAACCI/mpnbpM3f35o/s1600-h/image%25255B11%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-vxzow-RhWPQ/T_FUyWIBBhI/AAAAAAAACCQ/ZjPeiA9700E/image_thumb%25255B5%25255D.png?imgmax=800" width="284" height="243"></a></p> <p>Behind the scene RavenDB has indexed all the documents the the People collection using as a thumbprint the linq query we designed.</p> <p><strong>Staleness</strong></p> <p>“…Behind the scene RavenDB has indexed…” means that the indexing process is performed, at least and currently, in a different thread asynchronously. So when a new document is inserted, or an existing one is changed, the indexing services are triggered for an index rebuild.</p> <p>Since the process is asynchronous queries issued while the server is re-indexing are stale by design meaning that data returned by the query <strong>can</strong> be non consistent with the expected state:</p> <ol> <li>a document has been changed;</li> <li>the changed document should be included in the query results;</li> <li>…but since the indexing process has not yet completed the document is not included in the results;</li> <li>the query is stale (and we have an API we can use to discover the query status);</li></ol> <p><strong>that’s it</strong></p> <p>Is it a problem? well…no :-) take a report, it is stale by design, queries in general are stale by design. The problem, the real problem, is that we have convinced the user that:</p> <ul> <li>search for some data;</li> <li>not found what you are looking for?</li> <ul> <li>Insert the new data;</li></ul> <li>refresh the search;</li> <li>the new data are immediately there…</li></ul> <p>grrrr….mainly because in order <em>to simplify <strong>our </strong>job </em>we started to use transactions to <strong>lock</strong> the user in the process…blocking the calling process. Now think to a distributed system where everything is asynchronous, our application issues an insert request (even to a relational database) and its process is immediately left to move not without any blocking construct…the query immediately issued after the insert is not guaranteed to retrieve the previously inserted data, it is “likely” to retrieve.</p> <p>The solution is not a technical solution, the solution is a <strong>U</strong>ser e<strong>X</strong>perience solution. The technical problem is how long does an index takes to get ready…we’ll see :-)</p>  

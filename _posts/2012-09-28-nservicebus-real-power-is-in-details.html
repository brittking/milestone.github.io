---
layout: post
title: 'NServiceBus: real power is in the details'
date: '2012-09-28T10:14:00.000+02:00'
author: Mauro Servienti
tags:
- Domain Driven Design
- NServiceBus
- Architecture
modified_time: '2012-09-28T10:14:00.138+02:00'
thumbnail: http://lh4.ggpht.com/-Wax0FMgaOGc/UFvys2t1qrI/AAAAAAAACLY/CpwJWyANe6U/s72-c/image_thumb%25255B1%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-5355686462271780945
blogger_orig_url: http://milestone.topics.it/2012/09/nservicebus-real-power-is-in-details.html
---

<p><strong>Some background…</strong></p> <p><a href="http://blog.codiceplastico.com/melkio/" target="_blank">Alessandro</a> and I are working on a really cool and huge application (web application for the records) that is totally based on DDD, Event Sourcing and CQRS concepts.</p> <p>I can safely say that we are really happy with what we have achieved so far.</p> <p><strong>But…</strong></p> <p>At the early beginning we decided to have 2 different ways to handle domain events, basically we differentiate domain events running in-process and domain events that should also run out-of-process. The end result was pretty interesting because using the <a href="http://radical.codeplex.com/" target="_blank">Radical</a> Message Broker we have internal asynchronous events flowing in-process and eventually we have the ability to “transform” an event to something that can also be broadcasted over the wire using <a href="http://nservicebus.com" target="_blank">NServiceBus</a>.</p> <p><strong>Enter MongoDB</strong></p> <p>Within the ingredients of the recipe we are working on there is also <a href="http://www.mongodb.org/" target="_blank">MongoDB</a>, the popular open source nosql database, that is really cool but has some drawbacks, especially for the .net developers, that sometimes leads you to tweets like the following:</p> <blockquote> <p><a href="http://lh4.ggpht.com/-N_3-HVoeUZQ/UFvyrSoTroI/AAAAAAAACLQ/8KGIXvRnQyI/s1600-h/image%25255B3%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-Wax0FMgaOGc/UFvys2t1qrI/AAAAAAAACLY/CpwJWyANe6U/image_thumb%25255B1%25255D.png?imgmax=800" width="363" height="76"></a></p></blockquote> <p>to avoid working deeply with Map/Reduce I started to handle domain events, all sort of events, to de-normalize data on MongoDB so to achieve the same result that Map/Reduce leads to, but in a much much easier and sustainable way.</p> <p><strong>The problem</strong></p> <p>Runtime data de-normalization introduce the high risk of out-of-sync data: one of the de-normalizer fails and some data are not correctly de-normalized…</p> <p>If this happens it is a much bigger pain that the one produced by a day-by-day working with MongoDB Map/Reduce.</p> <p><strong>The root cause</strong></p> <p>In our scenario the main bottleneck/point-of-failure is the in memory message broker because due to the asynchronous nature of the broker we lead to have lots of threads running, and if one of this thread fails we have no easy way, well no options at all, to recover from the failure.</p> <p><strong>Enter MessageQueue</strong></p> <p>So the question is: can we replace everything and only use NServiceBus?</p> <p>why not :-) in the end NServiceBus does exactly the same thing, dispatches messages, but has all the advantages of a transactional and durable storage as the one provided out-of-the-box by the MessageQueue service.</p> <p>So now we can have de-normalization processes that fails, and if they fails the message (event) that triggered the de-normalization is simply put in the error queue, we can solve the bug and reply the message.</p> <p>We moved from a scenario with no recovery options to a scenario where the only problem is when the recovery will occur.</p> <p>A new step toward the “forget-data-corruption” has been made, and it was really easy, really.</p> <p>.m</p>  
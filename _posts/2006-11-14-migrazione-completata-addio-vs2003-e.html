---
layout: post
title: Migrazione completata, addio VS2003 e fx1.1
date: '2006-11-14T20:38:00.000+01:00'
author: Mauro Servienti
tags:
- Why not...
modified_time: '2012-01-25T21:24:38.402+01:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-7447592903847170805
blogger_orig_url: http://milestone.topics.it/2006/11/migrazione-completata-addio-vs2003-e.html
permalink: /2006/11/migrazione-completata-addio-vs2003-e.html
---

<span>Oggi, complice un pomeriggio un po' fiacco, ne ho approfittato per completare l'opera, ho definitivamente migrato tutte le applicazione che ho in sviluppo verso il fx 2.0 e VS2005, finalmente non ce la facevo più :-D</span><br> <span>Fondamentalmente tutto e filato abbastanza liscio a parte qualche magagna con P/Invoke e naturalmente con il mio "<em>amico</em>" Crystal Report (maledetto lui...).</span><br> <span>Per chiunque si trovasse di fronte alla stessa sistuazione e avesse un semplice metodo che imposta le fatidiche "<em>ConnectionInfo</em>" e "<em>TableLogonInfo</em>" al fine di poter switchare da un db ad un altro senza piangere in cinese... cominci a piangere perchè smette clamorosamente di funzionare... maledizione!</span><br> <span>Quello che facevo fino ad oggi era "<em>semplicemente</em>" questo:</span><br> protected string ParseDBObjectName( string name )<br>{<br>    if( name.IndexOf( " " ) != - 1 || name.IndexOf( "." ) != - 1 )<br>    {<br>        if( !name.StartsWith( "[" ) )<br>        {<br>            name = "[" + name;<br>        }          if( !name.EndsWith( "[" ) )<br>        {<br>            name = name + "]"<br>        }<br>    }      return name;<br>} protected void ApplyLogOnInfo( ReportDocument rpt, ConnectionInfo ci )<br>{<br>    foreach(Table tb in rpt.Database.Tables)<br>    {<br>        TableLogOnInfo loi = tb.LogOnInfo;<br>        loi.ConnectionInfo = ci;<br>        tb.ApplyLogOnInfo( loi );  <span>        if( tb.TestConnectivity() )<br>        {<br>            if( tb.Location.IndexOf(".") > 0 ) <br>            {<br>                tb.Location = this.ParseDBObjectName( <br>                            tb.Location.Substring(tb.Location.LastIndexOf( "." ) + 1 )<br>                            );<br>            }<br>            else<br>            {<br>                tb.Location = this.ParseDBObjectName( tb.Location );<br>            }<br>        }<br>    }<br>}</span><br> public void ApplyLogOnInfo()<br>{<br>    ConnectionInfo ci = new ConnectionInfo();  <span>    ci.ServerName = this.ServerName;<br>    ci.DatabaseName = this.DatabaseName;<br><br>    this.ApplyLogOnInfo( this.Report, ci ); </span><br>     foreach( ReportObject obj in this.Report.ReportDefinition.ReportObjects )<br>    {<br>        if( obj.Kind == ReportObjectKind.SubreportObject )<br>        {<br>            SubreportObject subObj = ( SubreportObject )obj;<br>            ReportDocument subRpt = this.Report.OpenSubreport(<br>                                                                                subObj.SubreportName );<br>            this.ApplyLogOnInfo( subRpt, ci );<br>        }<br>    } <br>} tutto ciò non fa altro che applicare in maniera ricorsiva su tutti gli oggetti (report e subreport) presenti nel report le stesse ConnectionInfo e TableLogonInfo, bene tutto ciò non funziona più, o meglio non produce il risultato atteso... all'inizio semplicemente panico... :-D Poi studiando un po' il problema e i soliti comprensibilissimi errori di CR, ma questi alla versione 11 o quel che è non hanno ancora capito nulla..., sono giunto alla soluzione decisamente banale :-S public void ApplyLogOnInfo()<br>{<br>    ConnectionInfo ci = new ConnectionInfo();  <span>    ci.ServerName = this.ServerName;<br>    ci.DatabaseName = this.DatabaseName;<br><font color="#004080">    <strong><em>ci.IntegratedSecurity = true;</em></strong></font></span><br> <span>è comparsa una nuova proprietà che non esisteva nella versione per il fx 1.1, naturalmente il suo valore di default, come mi sembra ovvio, è "false"...</span><br> <span>Tutto è bene quel che finisce bene :-D</span><br> <span>.m</span><br>

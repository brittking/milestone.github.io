---
layout: post
title: 'System.Transactions.IEnlistmentNotification: un approfondimento.'
date: '2008-08-26T18:35:00.000+02:00'
author: Mauro Servienti
tags:
- Software Mason
modified_time: '2012-08-04T17:54:12.553+02:00'
blogger_id: tag:blogger.com,1999:blog-6511237790974218081.post-2151761431944263866
blogger_orig_url: http://milestone.topics.it/2008/08/systemtransactionsienlistmentnotificati_26.html
---

<span>Qualche giorno fa ho avuto modo di <a href="http://blogs.ugidotnet.org/topics/archive/2008/08/13/system.transactions.ienlistmentnotification-interessantehellip-decisamente.aspx" target="_blank">(s)parlare</a> di come poter implementare <a href="http://msdn.microsoft.com/en-us/library/system.transactions.ienlistmentnotification.aspx" target="_blank">IEnlistmentNotification</a> in una propria classe di business al fine di realizzare un resource manager che sia utilizzabile all’interno di un <a href="http://msdn.microsoft.com/en-us/library/system.transactions.transactionscope.aspx" target="_blank">TransactionScope</a>. Quello che però ho dato per scontato è che si sappia come funziona il giochino. Ho già avuto modo di parlarne ampiamente in un <a href="http://msdn.microsoft.com/it-it/library/cc185103.aspx" target="_blank">articolo per MSDN</a> ma alcuni dettagli forse mancano ed è giusto riprenderli qui, partiamo da questo snippet:</span><br>              <span>using( TransactionScope scope = new TransactionScope() )   <br>{    <br>    //Code inside a transaction….    <br>    scope.Complete();    <br>}</span><br>    <span>la prima nota da fare è che la Dispose di TransactionScope non è una vera e propria Dispose() ma serve principalmente per concludere la transazione con un Rollback(), nel caso si sia verificata una exception e/o la Complete() non sia stata chiamata, o con una Commit() in caso di successo. Approfondendo ulteriormente quello che succede in caso di successo è:</span><br>  <ul>   <li>viene invocato TransactionScope.Complete();</li>    <li>il transaction a manger si segna che la transazione è completata;</li>    <li>scorre i “vari” resource manager “enlisted” nella transazione e chiama Prepare/Commit o SinglePhaseCommit a seconda del tipo di enlistment;</li>    <li>si conclude definitivamente la transazione;</li> </ul>  <span> Se infatti realizziamo un’implementazione banalissima in una applicazione console:</span><br>  <span>MyResourceManager rm = new MyResourceManager();   <br>using( TransactionScope tx = new TransactionScope() )    <br>{    <br>    Console.WriteLine( "TransactionScope created. ThreadId: {0}", Thread.CurrentThread.ManagedThreadId );    <br>    rm.DoWork();    <br>    tx.Complete();    <br>    Console.WriteLine( "Complete() called inside using block. ThreadId: {0}", Thread.CurrentThread.ManagedThreadId );    <br>} </span><br>  <span>Console.WriteLine( "Dispose() called outside using block. ThreadId: {0}", Thread.CurrentThread.ManagedThreadId );</span><br>  <span>dove MyResourceManager implementa IEnlistmentNotification, notiamo che:</span><br>  <span><a href="http://blogs.ugidotnet.org/images/blogs_ugidotnet_org/topics/WindowsLiveWriter/System.Transactions.IEnlistmentNotifica_729E/image_2.png" rel="lightbox"><img title="image" style="border-right: 0px; border-top: 0px; border-left: 0px; border-bottom: 0px" height="92" alt="image" src="http://blogs.ugidotnet.org/images/blogs_ugidotnet_org/topics/WindowsLiveWriter/System.Transactions.IEnlistmentNotifica_729E/image_thumb.png" width="244" border="0"></a> </span><br>  <span>Prepare e Commit sono successivi alla chiamata a Complete(), quindi un paio di tip:</span><br>  <ol>   <li>Non c’è nessuna garanzia che Prepare/Commit vengano chiamati nello stesso thread che sta gestendo la transazione, quindi non fate il benchè minimo affidamento su questo.</li>    <li>Commit() e Prepare() non possono assolutamente fallire pena nessun Rollback(), per essere precisi all’interno di prepare avete l’ultima possibilità di forzare un Rollback(); attraverso preparingEnlistment.ForceRollback() peccatro che non funzioni neanche a pagarlo… indagando un po’ più a fondo, cioè senza usare MSDN… :-(, si scopre che lo scenario deve essere quello di una transazione distributia e il nostro resource manager deve essere un durable resource manager… cioè tutto un’altro pianeta ;-)     <br>Sta di fatto che quindi la Commit() non deve fallire, il lavoro deve essere fatto all’interno della DoWork() e li devo:</li>    <ol>     <li>Eseguire l’enlistment nella transazione corrente, se presente;</li>      <li>eseguire le operazioni chje devo eseguire tenendo traccia dei singoli passaggi fatti in modo da poter fare un Rollback() granulare e preciso;</li>      <li>eseguire il tutto eventualmente su variabili/risorse temporanee per rispettare i principi di isolamento;</li>      <li>Nella Commit() confermare le operazioni fatte rendendo persistenti e visibili all’esterno le modifiche;</li>      <li>nell’eventulae Rollback() ripristinare lo stato precedente l’inizio della transazione;</li>   </ol>    <li>Terza nota, non proprio semplicissima da implementare: il <em>vostro</em> resource manager <u>deve</u> rispettare il livello di Isolamento che c’è impostato sulla transazione e quindi ad esempio acquisire lock sulle risorse o mascherare/consentire la lettura dei valori in maniera diversa a seconda che il chimante sia all’interno della transazione o meno… mi aspetto per cui che in uno scenario come questo:</li>    <span>TransactionOptions op = new TransactionOptions();     <br>op.IsolationLevel = System.Transactions.IsolationLevel.Serializable;      <br>using( TransactionScope tx = new TransactionScope( TransactionScopeOption.RequiresNew, op ) )      <br>{      <br>    IPerson aPerson = Repository.GetPerson();      <br>    aPerson.Name = "Mauro"; </span><br>    <span>    tx.Complete();     <br>}      <br>      <br>la lettura di aPerson.Name all’interno della transazione ritorni “Mauro” mentre se un thread esterno cercasse di leggere verrebbe accodato in attesa del completamento della transazione o che la risorsa si comportasse in base al livello di isolamento impostato.      <br>Per raggiungere questo scopo è decisamente più semplice se l’implementazione di IEnlistmentNotification la fate direttamente sulla risorsa in questione (IPerson in questo caso, sul PersonProxy per essere pignoli) piuttosto che su un terzo attore quale potrebbe essere una ipotetica classe PersonResourceManager.</span><br> </ol>  <span>.m</span><br>  